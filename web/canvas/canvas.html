<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>NewCanvas</title>
    <meta name="author" content="Dell Du">
    <meta name="description" content="Canvas is a standalone image annotator application packaged as single HTML file that runs on most modern web browsers.">
    <!-- BEGIN: Contents css-->
    <style>
        body { min-width:200px; padding:0; margin:0; font-family:sans-serif; }
* { box-sizing: border-box; }
input[type=text] { border:1px solid #cccccc; margin:0.6rem 0; padding:0.2rem 0.4rem; }
a { text-decoration:none; }
textarea { border:1px solid #cccccc; margin:0.6rem 0; padding:0.2rem 0.4rem; }

/* Top panel : #navbar, #toolbar */
.top_panel { font-size:0.9rem; display:block; background-color:#212121; color:#ffffff; z-index:1001; margin-bottom:1rem;}

/* Navigation menu bar that appear at the top */
.menubar { display:inline-block; height:1.8rem; } /* height needed to avoid extra bottom border */
.menubar a:link { color:#eeeeee; text-decoration:none; }
.menubar a:visited { color:#eeeeee; text-decoration:none; }
.menubar ul { display:block; padding:0; margin:0; }
.menubar li { display:inline; float:left; padding:0.45rem 1rem; }
.menubar li:hover { background-color:#616161; cursor:default; }

.menubar li ul { display:none; background-color:#212121; border:1px solid #616161; min-width:10rem; position:absolute; z-index:100; margin:0.4rem -1rem;}
.menubar li ul li { display:block; float:none; color:#eeeeee; margin:0; padding:0.6rem 1rem; }
.menubar li ul li:hover { cursor:pointer; }
.menubar li ul li.submenu_divider { margin:0 0.4rem; padding:0; height:1px; border-bottom:1px solid #424242; }
.menubar li:hover ul { display:block; }

/* toolbar containing small icons for tools */
.toolbar { display:inline-block; margin-left:1rem; }
.toolbar svg { fill:white; margin: 0.2rem 0.1rem; height:1.2rem;  -moz-user-select:none; -webkit-user-select:none; -ms-user-select:none;}
.toolbar svg:hover { fill:yellow; cursor:pointer; }
.toolbar svg:active { fill:white; }
.toolbar ul { display:inline-block; padding:0.2rem; margin:0; }
.toolbar li { display:inline; float:left; padding:0rem 0.3rem; border:1px solid white;} /* main menu items */
.toolbar li:hover { color:red; cursor:pointer; }

/* Middle panel: containing #image_panel, #leftsidebar */
.middle_panel { display:table; table-layout:fixed; width:100%; z-index:1; padding:0;}
#leftsidebar { display:none; z-index:10; vertical-align:top;}
#display_area { display:table-cell; width:100%; z-index:1; margin:0; padding-left:1em; vertical-align:top; }
/* layers of canvas */
#image_panel        { position:relative; outline:none; }
#image_panel img    { visibility:hidden; opacity:0; position:absolute; top:0px; left:0px; width:100%; height:100%; outline:none; }
#image_panel canvas { position:absolute; top:0px; left:0px; outline:none;}
#image_panel .visible { visibility:visible !important; opacity:1 !important; }
#image_panel label>img { visibility:visible; opacity:1; position:relative; width:auto; height:4em; outline:none; }

/* image grid view */
#image_grid_panel { position:relative; margin:0; padding:0; width:100%; }
#image_grid_panel #image_grid_toolbar { display:block; font-size:small; padding:0.5rem 0;}
#image_grid_panel #image_grid_toolbar select { font-size:small; }
#image_grid_panel #image_grid_toolbar .tool { display:inline; margin:0 0.5rem;}
#image_grid_panel #image_grid_group_panel { font-size:small; }
#image_grid_panel #image_grid_group_panel select { font-size:small; }
#image_grid_panel #image_grid_group_panel .image_grid_group_toolbar { display:inline; margin-left: 2rem;}
#image_grid_panel #image_grid_group_panel .image_grid_group_toolbar select { margin:0 0.2rem; padding:0; font-size:small;}

#image_grid_panel #image_grid_nav { display:inline; font-size:small; padding-left:0.5rem; margin-top:0.2rem; }
#image_grid_panel #image_grid_nav span { margin: 0 0.2rem; }
#image_grid_panel #image_grid_content { position:relative; overflow:hidden; margin:0; padding:0; outline:none; }
#image_grid_panel #image_grid_content #image_grid_content_image_list_set img { margin:0.3em; padding:0; border:0.2em solid #ffffff; outline:0.1em solid #0066ff;}
#image_grid_panel #image_grid_content #image_grid_content_image_list_set .not_sel { opacity:0.6; outline:none; }
#image_grid_panel #image_grid_content #image_grid_content_image_list_set { position:absolute; top:0; left:0; width:100%; height:100%; }
#image_grid_panel #image_grid_content #image_grid_content_shape { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; }
#image_grid_panel #image_grid_content img { float:left; margin:0; }

#leftsidebar_collapse_panel { display:none; position:relative; z-index:10; vertical-align:top; }
#leftsidebar_show_button { font-size:large; margin-left:0.1rem; }
#leftsidebar_show_button:hover { color:red; cursor: pointer; }

/* Left sidebar accordion */
button.leftsidebar_accordion { font-size:large; background-color:#f2f2f2; cursor:pointer; padding:0.5em 0.5em; width:100%; text-align:left; border:0; outline:none; }
button.leftsidebar_accordion:focus { outline: none; }
button.leftsidebar_accordion.active, button.leftsidebar_accordion:hover { background-color: #e6e6e6; }
button.leftsidebar_accordion:after { content:'\02795'; color:#4d4d4d; float:right; }
button.leftsidebar_accordion.active:after { content: '\2796'; }
.leftsidebar_accordion_panel { display:none; padding:0 0.5em; font-size:small; border-right:2px solid #f2f2f2; border-bottom:2px solid #f2f2f2; }
.leftsidebar_accordion_panel.show { display:block; }

/* Keyboard shortcut panel */
.leftsidebar_accordion_panel table { border-collapse:collapse; }
.leftsidebar_accordion_panel td { border:1px solid #f2f2f2; padding:0.2rem 0.4rem; }

/* buttons */
.button_panel { display:inline-block; width:100%; margin:0.2rem 0; }
.button_panel .text_button, .text_button { color: #0000ff; padding: 0.2rem 0.2rem; -moz-user-select:none; -webkit-user-select:none; -ms-user-select:none; }
.button_panel .flush_right { float:right; }
.button_panel .text_button:hover, .text_button:hover { cursor:pointer; }
.button_panel .text_button:active, .text_button:active { color: #000000; }
.button_panel .active { border-bottom:1px solid black; }
.button_panel .button { display:inline-block; padding:0.35rem 0.5rem; margin:0 0.05rem; cursor:pointer; background-color:#cccccc; border-radius:0.2rem; -moz-user-select:none; -webkit-user-select:none; -ms-user-select:none; }
.button_panel .button:hover { background-color:black; color:white; }

/* overlay panel used to gather user inputs before invoking a function using invoke_with_user_inputs() */
#user_input_panel { position:fixed; display:none; width:100%; height:100%; top:0; left:0; right:0; bottom:0; background-color: rgba(0,0,0,0.6); z-index:1002; }
#user_input_panel .content { position:fixed; background-color:white; top:50%; left:50%; transform:translate(-50%,-50%);  -webkit-transform: translate(-50%, -50%); -moz-transform: translate(-50%, -50%);  -o-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); padding:2rem 4rem;}
#user_input_panel .content .title { font-size:large; font-weight:bold; }
#user_input_panel .content .user_inputs { display:table; width:100%; border-collapse:collapse;}
#user_input_panel .content .user_inputs .row { display:table-row; }
#user_input_panel .content .user_inputs .cell { display:table-cell; padding:1rem 0.5rem; vertical-align:middle; border:1px solid #f2f2f2; }
#user_input_panel .content .user_confirm { display:table; width:100%; text-align:center; margin:2rem 0;}
#user_input_panel .content .user_confirm .ok { display:table-cell; width:48%; }
#user_input_panel .content .user_confirm .cancel { display:table-cell; width:48%; }
#user_input_panel .content .warning { color:red; }

/* Attribute editor */
#annotation_editor_panel { position:fixed; display:none; width:100%; left:0; bottom:0; background-color:white; border-top:2px solid #cccccc; padding:0.2em 1em; overflow:auto; z-index:1001; box-shadow: 0 0 1em #cccccc;}
#annotation_editor { display:table; margin-bottom:3em; border-collapse:collapse; font-size:inherit; position: absolute; background-color:white; }
#annotation_editor .row { display:table-row; }
#annotation_editor .highlight .col { background-color:#e6e6e6;}

#annotation_editor .col { display:table-cell; padding:0.4em 0.6em; border:1px solid #000000; vertical-align:middle; font-size:inherit; }
#annotation_editor .header { font-weight:bold; }
#annotation_editor .id { font-weight:bold; }
#annotation_editor .col input[type=checkbox] { vertical-align:middle; }
#annotation_editor .col input[type=radio] { vertical-align:middle; font-size:inherit; }
#annotation_editor .col label { vertical-align:middle; font-size:inherit; }
#annotation_editor .col textarea { border:0.1em solid #cccccc; padding:0; margin:0; font-size:inherit; background-color:#ffffff; }
#annotation_editor .col textarea:focus { border:0.1em dashed #cccccc; }
#annotation_editor .col span { display:block; }
#annotation_editor .col horizontal_container { display:inline-block; }

#annotation_editor .col .img_options { display:inline; }
#annotation_editor .col .img_options .imrow { display:block; }
#annotation_editor .col .img_options span { display:inline-block; margin: 0.2rem 0.4rem;}
#annotation_editor .col .img_options span img { height:4em; }
#annotation_editor .col .img_options p { margin:0; padding:0; font-size:inherit; }
#annotation_editor .col .img_options input[type=radio] { display:none; }
#annotation_editor .col .img_options input[type=radio] + label { display:block; cursor:pointer; text-align:center;}
#annotation_editor .col .img_options input[type=radio]:checked + label { border: 0.1em solid black; background-color:#cccccc; cursor:default; font-size:inherit; }

/* Project */
#project_info_panel      { display:table; border-collapse:collapse; font-size:0.8rem; }
#project_info_panel .row { display:table-row; }
#project_info_panel .col { display:table-cell; padding:0.4rem 0.1rem; border:none;  }
#project_info_panel .col input[type=text] { font-size:0.8rem; border:none; border-bottom:1px solid #cccccc; margin: 0; width:100%;}
#project_info_panel .col input:focus      { border-bottom:1px solid #000000; background-color:#f2f2f2; color:#000000; }

/* shape selection panel inside leftsidebar */
ul.region_shape          { font-size:xx-large; list-style-type:none; overflow:hidden; padding:0.4em 0; margin:0; }
ul.region_shape li       { float:left; padding:0 0.2em; fill:#ffffff; stroke:#000000; }
ul.region_shape li:hover { cursor:pointer; fill:#ffffff; stroke:#ff0000; }
ul.region_shape .selected { fill:#ffffff; stroke:#ff0000; }

/* cursor coordinates inside shape selection panel in leftsidebar */
#region_info { font-size:0.8em; margin-bottom:0.4em; }

/* Loaded image list shown in leftsidebar panel */
#img_fn_list    { display:none; font-size:small; overflow:scroll; min-height:10rem; max-height:25rem; }
#img_fn_list ul { position:relative; line-height:1.3em; margin:0; padding:0; list-style-type:none;}
#img_fn_list li { white-space:nowrap; display:block; padding:0 0.4rem; }
#img_fn_list li:hover   { background-color:#d5e5ff; cursor:pointer; }
#img_fn_list .error     { color:red; }
#img_fn_list .sel       { border-left:0.2rem solid black !important; font-weight:bold; }
#img_fn_list .buffered  { border-left:0.2rem solid #cccccc; }

#message_panel         { display:block; width:100%; position:fixed; bottom:0px; z-index:9999; text-align:center; }
#message_panel .content { display:inline; margin:auto; background-color:#000000; color:#ffff00; font-size:small; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; line-height:2rem; padding: 0.5rem 2rem;}

.text_panel    { display:none; margin:auto; font-size:medium; line-height:1.3em; margin: 0; max-width:700px; }
.text_panel li { margin:1em 0; text-align:left; }
.text_panel p  { text-align:left; }

.svg_button:hover { cursor:pointer; }

/* Loading spinbar */
.loading_spinbox        { display:inline-block; border:0.4em solid #cccccc; border-radius:50%; border-top:0.4em solid black; border-bottom:0.4em solid black;-webkit-animation:spin 2s linear infinite; animation:spin 2s linear infinite; }
@-webkit-keyframes spin { 0% { -webkit-transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); } }
@keyframes spin         { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

#invisible_file_input { width:0.1px; height:0.1px; opacity:0; overflow:hidden; position:absolute; z-index:-1; }

.display_none  { display:none !important; }
.display_block { display:block !important; }

/* project settings */
#settings_panel { font-size:1rem; border-collapse:collapse; width:95%; }
#settings_panel a { border: 1px solid #f2f2f2; }
#settings_panel .row { display:table-row; border-bottom:1px solid #f2f2f2; }
#settings_panel .variable { display:table-cell; width:60%; padding:0.5rem 0.5rem; }
#settings_panel .variable div { display:block; }
#settings_panel .variable .name { }
#settings_panel .variable .desc { font-size:0.7em; color:#808080; padding:0.2rem 0rem; }
#settings_panel .value { display:table-cell; vertical-align:middle; padding-left:1rem; }

/* page {about, help, file not found, etc.} */
.display_area_content { } /* this class is used to clear the display area content */
.narrow_page_content li { font-size:0.9rem; margin: 0.4rem 0; }
.narrow_page_content { width:60%; }

.force_small_font { font-size:small !important; }
.key { font-family:monospace; padding:1px 6px; background:linear-gradient(to bottom,#f0f0f0,#fcfcfc);; border:1px solid #e0e0e0; white-space:nowrap; color:#303030; border-bottom-width:2px; border-radius:3px; font-size:1.2em; }
</style>
    <!-- END: Contents css-->
</head>

<body onload="nc_init()" onresize="nc_refresh()">
    <!--
        SVG icon set definitions
        Material icons downloaded from https://material.io/icons
      -->
    <svg style="display:none;" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs>
            <symbol id="shape_rectangle">
                <title>Rectangle</title>
                <rect width="20" height="12" x="6" y="10" stroke-width="1"></rect>
            </symbol>
            <symbol id="shape_circle">
                <title>Circle</title>
                <circle r="10" cx="16" cy="16" stroke-width="1"></circle>
            </symbol>
            <symbol id="shape_ellipse">
                <title>Ellipse</title>
                <ellipse rx="12" ry="8" cx="16" cy="16" stroke-width="1"></ellipse>
            </symbol>
            <symbol id="shape_polygon">
                <title>Polygon</title>
                <path d="M 15.25,2.2372 3.625,11.6122 6,29.9872 l 20.75,-9.625 2.375,-14.75 z" stroke-width="1"></path>
            </symbol>
            <symbol id="shape_point">
                <title>Point</title>
                <circle r="3" cx="16" cy="16" stroke-width="1"></circle>
            </symbol>
            <symbol id="shape_polyline">
                <title>Polyline</title>
                <path d="M 2,12 10,24 18,12 24,18" stroke-width="1"></path>
                <circle r="1" cx="2" cy="12" stroke-width="1"></circle>
                <circle r="1" cx="10" cy="24" stroke-width="1"></circle>
                <circle r="1" cx="18" cy="12" stroke-width="1"></circle>
                <circle r="1" cx="24" cy="18" stroke-width="1"></circle>
            </symbol>
            <!-- Material icons downloaded from https://material.io/icons -->
            <symbol id="icon_settings">
                <path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path>
            </symbol>
            <symbol id="icon_save">
                <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"></path>
            </symbol>
            <symbol id="icon_open">
                <path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z"></path>
            </symbol>
            <symbol id="icon_grid">
                <path d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 20H4v-4h4v4zm0-6H4v-4h4v4zm0-6H4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4z"></path>
            </symbol>
            <symbol id="icon_next">
                <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path>
            </symbol>
            <symbol id="icon_prev">
                <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>
            </symbol>
            <symbol id="icon_list">
                <path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"></path>
            </symbol>
            <symbol id="icon_zoomin">
                <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z" />
            </symbol>
            <symbol id="icon_zoomout">
                <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z"></path>
            </symbol>
            <symbol id="icon_copy">
                <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path>
            </symbol>
            <symbol id="icon_paste">
                <path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"></path>
            </symbol>
            <symbol id="icon_pasten">
                <path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"></path>
                <text x="8" y="18">n</text>
            </symbol>
            <symbol id="icon_selectall">
                <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z"></path>
            </symbol>
            <symbol id="icon_close">
                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
            </symbol>
            <symbol id="icon_filedownload">
                <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path>
            </symbol>
        </defs>
    </svg>
    <!-- used by invoke_with_user_inputs() to gather user inputs -->
    <div id="user_input_panel"></div>
    <!-- to show status messages -->
    <div id="message_panel">
        <div id="message_panel_content" class="content"></div>
    </div>
    <!-- spreadsheet like editor for annotations -->
    <div id="annotation_editor_panel">
        <!-- here, a child div with id="annotation_editor" is added by javascript -->
    </div>
    <div class="top_panel" id="ui_top_panel">
        <!-- menu bar -->
        <div class="menubar">
            <ul>
                <li onclick="show_home_panel()" style="cursor:pointer;">Home</li>
                <li>Project
                    <ul>
                        <li onclick="settings_cancel()" title="Show/edit project settings">Settings</li>
                        <li class="submenu_divider"></li>
                        <li onclick="open_project_from_json_file()" title="Open a project (from a JSON file)">Open</li>
                        <li onclick="save_project_with_confirm()" title="Save project (as a JSON file)">Save</li>
                        <li class="submenu_divider"></li>
                        <li onclick="project_add_files()" title="Add files">Add files</li>
                        <li onclick="project_remove_file()" title="Remove selected file">Remove file</li>
                    </ul>
                </li>
                <li>View
                    <ul>
                        <li onclick="toggle_grid_images()" title="Switch to Image Single/Grid View">Toggle image grid view</li>
                        <li onclick="leftsidebar_toggle()" title="Show or hide sidebar shown in left hand side">Toggle left sidebar</li>
                        <li onclick="toggle_file_list_visibility()" title="Show or hide a panel to file list">Toggle image filename list</li>
                        <li class="submenu_divider"></li>
                        <li onclick="toggle_boundary_visibility()" title="Show or hide boundaries">Show/hide region boundaries (b)</li>
                        <li onclick="toggle_region_id_visibility()" title="Show or hide id labels">Show/hide region labels (l)</li>
                        <li onclick="toggle_region_info_visibility()" title="Show or hide image coordinates">Show/hide region info.</li>
                        <li class="submenu_divider"></li>
                        <li onclick="show_annotation_data()" title="Preview annotations">Preview Annotations</li>
                    </ul>
                </li>
                <li>Help
                    <ul>
                        <li onclick="set_display_area_content(NC_DISPLAY_AREA_CONTENT_NAME.PAGE_GETTING_STARTED)" title="Show a guide to getting started">Getting Started</li>
                        <li class="submenu_divider"></li>
                        <li onclick="set_display_area_content(NC_DISPLAY_AREA_CONTENT_NAME.PAGE_ABOUT)" title="Show more details about this application">About</li>
                    </ul>
                </li>
            </ul>
        </div> <!-- end of menubar -->
        <!-- Shortcut toolbar -->
        <div class="toolbar">
            <svg onclick="open_project_from_json_file()" viewbox="0 0 24 24">
                <use xlink:href="#icon_open"></use>
                <title>Open Project</title>
            </svg>
            <svg onclick="save_project_with_confirm()" viewbox="0 0 24 24">
                <use xlink:href="#icon_save"></use>
                <title>Save Project</title>
            </svg>
            <svg onclick="toggle_grid_images()" viewbox="0 0 24 24">
                <use xlink:href="#icon_grid"></use>
                <title>View Grid Images</title>
            </svg>
            <svg onclick="move_to_prev_image()" viewbox="0 0 24 24">
                <use xlink:href="#icon_prev"></use>
                <title>Previous</title>
            </svg>
            <svg onclick="toggle_file_list_visibility()" viewbox="0 0 24 24">
                <use xlink:href="#icon_list"></use>
                <title>Toggle Filename List</title>
            </svg>
            <svg onclick="move_to_next_image()" viewbox="0 0 24 24">
                <use xlink:href="#icon_next"></use>
                <title>Next</title>
            </svg>
            <svg onclick="zoom_in()" viewbox="0 0 24 24">
                <use xlink:href="#icon_zoomin"></use>
                <title>Zoom In</title>
            </svg>
            <svg onclick="zoom_out()" viewbox="0 0 24 24">
                <use xlink:href="#icon_zoomout"></use>
                <title>Zoom Out</title>
            </svg>
            <svg onclick="download_as_image()" viewbox="0 0 24 24">
                <use xlink:href="#icon_filedownload"></use>
                <title>Download annotations as Image</title>
            </svg>
            <svg onclick="select_all_regions()" viewbox="0 0 24 24">
                <use xlink:href="#icon_selectall"></use>
                <title>Select All Regions</title>
            </svg>
            <svg onclick="copy_selected_regions()" viewbox="0 0 24 24">
                <use xlink:href="#icon_copy"></use>
                <title>Copy Regions</title>
            </svg>
            <svg onclick="paste_selected_regions()" viewbox="0 0 24 24">
                <use xlink:href="#icon_paste"></use>
                <title>Paste Region</title>
            </svg>
            <svg onclick="delete_selected_regions()" viewbox="0 0 24 24">
                <use xlink:href="#icon_close"></use>
                <title>Delete Region</title>
            </svg>
        </div>
        <!-- end of shortcut toolbar -->
        <input type="file" id="invisible_file_input" name="files[]" style="display:none">
    </div> <!-- endof #top_panel -->
    <!-- Middle Panel contains a left-sidebar and image display areas -->
    <div class="middle_panel">
        <!-- this panel contains a button to shows the left side bar -->
        <div id="leftsidebar_collapse_panel">
            <span class="text_button" onclick="leftsidebar_toggle()" title="Show left sidebar">&rtrif;</span>
        </div>
        <div id="leftsidebar">
            <div class="leftsidebar_accordion_panel show" style="float:right; border:2px solid #f2f2f2;">
                <span class="text_button" onclick="leftsidebar_decrease_width()" title="Reduce width of left side toolbar">&larr;</span>
                <span class="text_button" onclick="leftsidebar_increase_width()" title="Increase width of left side toolbar">&rarr;</span>
                <span class="text_button" onclick="leftsidebar_toggle()" title="Show/hide left side toolbar">&ltrif;</span>
            </div>
            <!-- Shape -->
            <button class="leftsidebar_accordion active">Shape</button>
            <div class="leftsidebar_accordion_panel show">
                <ul class="region_shape">
                    <li id="region_shape_rect" class="selected" onclick="select_shape('rect')" title="Rectangle">
                        <svg height="32" viewbox="0 0 32 32">
                            <use xlink:href="#shape_rectangle"></use>
                        </svg>
                    </li>
                    <li id="region_shape_circle" onclick="select_shape('circle')" title="Circle">
                        <svg height="32" viewbox="0 0 32 32">
                            <use xlink:href="#shape_circle"></use>
                        </svg>
                    </li>
                    <li id="region_shape_ellipse" onclick="select_shape('ellipse')" title="Ellipse"><svg height="32" viewbox="0 0 32 32">
                            <use xlink:href="#shape_ellipse"></use>
                        </svg></li>
                    <li id="region_shape_polygon" onclick="select_shape('polygon')" title="Polygon"><svg height="32" viewbox="0 0 32 32">
                            <use xlink:href="#shape_polygon"></use>
                        </svg></li>
                    <li id="region_shape_point" onclick="select_shape('point')" title="Point"><svg height="32" viewbox="0 0 32 32">
                            <use xlink:href="#shape_point"></use>
                        </svg></li>
                    <li id="region_shape_polyline" onclick="select_shape('polyline')" title="Polyline"><svg height="32" viewbox="0 0 32 32">
                            <use xlink:href="#shape_polyline"></use>
                        </svg></li>
                </ul>
                <div id="region_info" class="display_none">&nbsp;</div>
            </div>
            <!--Color-->
            <button class="leftsidebar_accordion active">Color</button>
            <div class="leftsidebar_accordion_panel show">
                <input type="color" id="region_color_picker" title="Color Picker" onchange="select_color(this.value)">
            </div>
            <!-- Project -->
            <button class="leftsidebar_accordion active" id="project_panel_title">Project</button>
            <div class="leftsidebar_accordion_panel show" id="file_list_panel">
                <div id="project_info_panel">
                    <div class="row">
                        <span class="col"><label for="project_name">Name: </label></span>
                        <span class="col"><input type="text" value="" onchange="change_project_name(this)" id="project_name" title="project name"></span>
                    </div>
                </div>
                <div id="project_tools_panel">
                    <div class="button_panel" style="margin:0.1rem 0;">
                        <select style="width:48%" id="filelist_preset_filters_list" onchange="file_list_onpreset_filter()" title="Filter file list using predefined filters">
                            <option value="all">All files</option>
                            <option value="files_without_region">Show files without regions</option>
                            <option value="files_error_loading">Files that could not be loaded</option>
                            <option value="regex">Regular Expression</option>
                        </select>
                        <input style="width:50%" type="text" placeholder="regular expression" oninput="file_list_onregex()" id="file_list_regex" title="Filter using regular expression">
                    </div>
                </div>
                <div id="img_fn_list"></div>
                <p>
                    <div class="button_panel">
                        <span class="button" onclick="project_add_files()" title="Add files">Add Files</span>
                        <span class="button" onclick="project_remove_file()" title="Remove selected file">Remove File</span>
                    </div>
                </p>
            </div>
            <button class="leftsidebar_accordion">Shortcut</button>
            <div class="leftsidebar_accordion_panel">
                <div style="display:block; text-align:center; padding:1rem;">Available Only on Image Focus</div>
                <table>
                    <tr>
                        <td style="width:8em;"><span class="key">&larr;</span>&nbsp;<span class="key">&uarr;</span>&nbsp;<span class="key">&rarr;</span>&nbsp;<span class="key">&darr;</span></td>
                        <td>Move selected region by 1 px</td>
                    </tr>
                    <tr>
                        <td><span class="key">a</span></td>
                        <td>Select all regions</td>
                    </tr>
                    <tr>
                        <td><span class="key">c</span></td>
                        <td>Copy selected regions</td>
                    </tr>
                    <tr>
                        <td><span class="key">v</span></td>
                        <td>Paste selected regions</td>
                    </tr>
                    <tr>
                        <td><span class="key">d</span></td>
                        <td>Delete selected regions</td>
                    </tr>
                    <tr>
                        <td><span class="key">Ctrl</span> + Wheel</td>
                        <td>Zoom in/out</td>
                    </tr>
                    <tr>
                        <td><span class="key">l</span></td>
                        <td>Toggle label</td>
                    </tr>
                    <tr>
                        <td><span class="key">b</span></td>
                        <td>Toggle boundary</td>
                    </tr>
                    <tr>
                        <td><span class="key">Enter</span></td>
                        <td>Finish drawing polyshape</td>
                    </tr>
                    <tr>
                        <td><span class="key">Backspace</span></td>
                        <td>Delete last polyshape vertex</td>
                    </tr>
                </table>
                <div style="display:block; text-align:center; padding:1rem;">Always Available</div>
                <table>
                    <tr>
                        <td><span class="key">+</span>&nbsp;<span class="key">-</span>&nbsp;<span class="key">=</span></td>
                        <td>Zoom in/out/reset</td>
                    </tr>
                    <tr>
                        <td><span class="key">Home</span> / <span class="key">h</span></td>
                        <td>Jump to first image</td>
                    </tr>
                    <tr>
                        <td><span class="key">End</span> / <span class="key">e</span></td>
                        <td>Jump to last image</td>
                    </tr>
                    <tr>
                        <td><span class="key">PgUp</span> / <span class="key">u</span></td>
                        <td>Jump several images</td>
                    </tr>
                    <tr>
                        <td><span class="key">PgDown</span> / <span class="key">d</span></td>
                        <td>Jump several images</td>
                    </tr>
                    <tr>
                        <td><span class="key">Esc</span></td>
                        <td>Cancel ongoing task</td>
                    </tr>
                </table>
            </div>
        </div> <!-- end of leftsidebar -->
        <!-- Main display area: contains image canvas, ... -->
        <div id="display_area">
            <div id="image_panel" class="display_area_content display_none">
                <!-- buffer images using <img> element will be added here -->
                <canvas id="region_canvas" width="1" height="1" tabindex="1">Sorry, your browser does not support HTML5 Canvas.</canvas>
            </div>
            <div id="image_grid_panel" class="display_area_content display_none">
                <div id="image_grid_group_panel">
                    <span class="tool">Group by&nbsp; <select id="image_grid_toolbar_group_by_select" onchange="image_grid_onchange_group_by_select(this)"></select></span>
                </div>
                <div id="image_grid_toolbar">
                    <span>Selected</span>
                    <span id="image_grid_group_by_sel_img_count">0</span>
                    <span>of</span>
                    <span id="image_grid_group_by_img_count">0</span>
                    <span>images in current group, show</span>
                    <span>
                        <select id="image_grid_show_image_policy" onchange="image_grid_onchange_show_image_policy(this)">
                            <option value="all">all images</option>
                            <option value="first_mid_last">only first, middle and last image</option>
                            <option value="even_indexed">even indexed images (i.e. 0,2,4,...)</option>
                            <option value="odd_indexed">odd indexed images (i.e. 1,3,5,...)</option>
                            <option value="gap5">images 1, 5, 10, 15,...</option>
                            <option value="gap25">images 1, 25, 50, 75, ...</option>
                            <option value="gap50">images 1, 50, 100, 150, ...</option>
                        </select>
                    </span>
                    <div id="image_grid_nav"></div>
                </div>
                <div id="image_grid_content">
                    <div id="image_grid_content_image_list_set"></div>
                </div>
                <div id="image_grid_info">
                </div>
            </div> <!-- end of image grid panel -->
            <div id="settings_panel" class="display_area_content display_none">
                <h2>Settings</h2>
                <div class="row">
                    <div class="variable">
                        <div class="name">Project Name</div>
                    </div>
                    <div class="value">
                        <input type="text" id="nc_settings.project.name" />
                    </div>
                </div>
                <div class="row">
                    <div class="variable">
                        <div class="name">Default Path</div>
                        <div class="desc">If all images in your project are saved in a single folder, set the default path to the location of this folder. The application will load images from this folder by default. Note: a default path of <code>"./"</code> indicates that the folder containing <code>nc.html</code> application file also contains the images in this project. For example: <code>datasets/</code></div>
                    </div>
                    <div class="value">
                        <input type="text" id="nc_settings.core.default_filepath" />
                    </div>
                </div>
                <div class="row">
                    <div class="variable">
                        <div class="name">Default Labels</div>
                        <div class="desc">Define lables including bg (background) with delimitor ','</div>
                    </div>
                    <div class="value">
                        <input type="text" id="nc_settings.core.default_labels" />
                    </div>
                </div>
                <div class="row">
                    <div class="variable">
                        <div class="name">Region Label</div>
                        <div class="desc">By default, each region in an image showing with region-id.</div>
                    </div>
                    <div class="value">
                        <select id="nc_settings.ui.image.region_label">
                            <option value="id" selected>ID</option>
                            <option value="label" selected>Label</option>
                        </select>
                    </div>
                </div>
                <div class="row">
                    <div class="variable">
                        <div class="name">Region Color</div>
                        <div class="desc">By default, each region is drawn using a single color.</div>
                    </div>
                    <div class="value">
                        <input type="text" id="nc_settings.ui.image.region_color" />
                    </div>
                </div>
                <div class="row">
                    <div class="variable">
                        <div class="name">Region Label Font</div>
                        <div class="desc">Font size and font family for showing region labels.</div>
                    </div>
                    <div class="value">
                        <input id="nc_settings.ui.image.region_label_font" placeholder="12px Arial" />
                    </div>
                </div>
                <div class="row">
                    <div class="variable">
                        <div class="name">Preload Buffer Size</div>
                        <div class="desc">Images are preloaded in buffer to allow smoother navigation of next/prev images. A large buffer size may slow down the overall browser performance. To disable preloading, set buffer size to 0.</div>
                    </div>
                    <div class="value">
                        <input type="text" id="nc_settings.core.buffer_size" />
                    </div>
                </div>
                <div class="row" style="border:none;">
                    <button onclick="settings_save()" value="save_settings" style="margin-top:2rem">Save</button>
                    <button onclick="settings_cancel()" value="cancel_settings" style="margin-left:2rem;">Cancel</button>
                </div>
            </div>
            <div id="page_start_info" class="display_area_content display_none narrow_page_content"></div>
            <div id="page_getting_started" class="display_area_content display_none narrow_page_content">
                <p>A more detailed user guide is <a href="#">available here</a>.</p>
            </div>
            <div id="page_load_ongoing" class="display_area_content narrow_page_content">
                <div style="text-align:center">
                    <div style="margin-top:4rem">Loading ...</div>
                </div>
            </div>
            <div id="page_about" class="display_area_content display_none" style="width:40rem !important">
                <p>Canvas 1.0.0, thanks all VIA team members ! This version base on VIA 2.0.10. </p>
                <p>---- <a href="18588220928@163.com">Dell Du</a></p>
            </div>
        </div> <!-- end of page_about -->
    </div> <!-- end of display_area -->
    </div> <!-- end of middle_panel -->
    <!-- START: Contents js-->
    <script>
    "use strict";

    var NC_VERSION = '1.0.0';
    var NC_NAME = 'Canvas';
    var NC_REGION_SHAPE = {
        RECT: 'rect',
        CIRCLE: 'circle',
        ELLIPSE: 'ellipse',
        POLYGON: 'polygon',
        POINT: 'point',
        POLYLINE: 'polyline'
    };

    var NC_DISPLAY_AREA_CONTENT_NAME = {
        IMAGE: 'image_panel',
        IMAGE_GRID: 'image_grid_panel',
        SETTINGS: 'settings_panel',
        PAGE_404: 'page_404',
        PAGE_GETTING_STARTED: 'page_getting_started',
        PAGE_ABOUT: 'page_about',
        PAGE_START_INFO: 'page_start_info',
    };

    var NC_REGION_EDGE_TOL = 5; // pixel
    var NC_REGION_CONTROL_POINT_SIZE = 2;
    var NC_POLYGON_VERTEX_MATCH_TOL = 5;
    var NC_REGION_MIN_DIM = 3;
    var NC_MOUSE_CLICK_TOL = 2;
    var NC_ELLIPSE_EDGE_TOL = 0.2; // euclidean distance
    var NC_THETA_TOL = Math.PI / 18; // 10 degrees
    var NC_POLYGON_RESIZE_VERTEX_OFFSET = 100;
    var NC_CANVAS_DEFAULT_ZOOM_LEVEL_INDEX = 3;
    var NC_CANVAS_ZOOM_LEVELS = [0.25, 0.5, 0.75, 1.0, 1.5, 2.0, 2.5, 3.0, 4, 5, 6, 7, 8, 9, 10];

    // xxxx9999
    var NC_REGION_COLOR_LIST = ["#E69F00", "#56B4E9", "#009E73", "#D55E00", "#CC79A7", "#F0E442", "#ffffff"];

    // control points in all shapes
    var NC_REGION_CONTROL_POINTS_RADIUS = 3;
    var NC_THEME_CONTROL_POINT_COLOR = '#ff0000';

    // radius of control points in a point
    var NC_REGION_POINT_RADIUS = 3;
    var NC_REGION_POINT_RADIUS_DEFAULT = 3;

    var NC_THEME_REGION_BOUNDARY_WIDTH = 1;
    var NC_THEME_BOUNDARY_LINE_COLOR = "black";
    var NC_THEME_BOUNDARY_FILL_COLOR = "yellow";
    var NC_THEME_SEL_REGION_FILL_COLOR = "#808080";
    var NC_THEME_SEL_REGION_FILL_BOUNDARY_COLOR = "yellow";
    var NC_THEME_SEL_REGION_OPACITY = 0.5;
    var NC_THEME_MESSAGE_TIMEOUT_MS = 5000;

    var NC_CSV_SEP = ',';
    var NC_CSV_KEYVAL_SEP = ':';

    var nc_image_count = 0; // count of the loaded images
    var nc_image_index = -1; // There are two ways to change it: 1) image_grid_dblclick_handler, 2) nc_show_image()
    var nc_image_id = ''; // nc_image_id = nc_image_id_list[nc_image_index], id={filename+length}
    var nc_current_image_filename; // nc_current_image_filename = nc_image_metadata[nc_image_id].filename;
    var nc_current_image_loaded = false;
    var nc_image_metadata = {}; // data structure to store loaded images metadata
    var nc_image_src = {}; // image content {abs. path, url, base64 data, etc}
    var nc_image_fileref = {}; // reference to local images selected by using browser file selector
    var nc_current_image; // image object of DOM
    var nc_current_image_width;
    var nc_current_image_height;

    var nc_canvas_regions = []; // image regions spec. in canvas space,
    // 1) update: nc_load_canvas_regions() --- paste_selected_regions, nc_show_image_from_buffer, set_zoom
    var nc_canvas_scale = 1.0; // current scale of canvas image

    // image canvas
    var nc_display_area = document.getElementById('display_area');
    var nc_img_panel = document.getElementById('image_panel');
    var nc_reg_canvas = document.getElementById('region_canvas');
    var nc_reg_ctx; // initialized in nc_init()
    var nc_canvas_width, nc_canvas_height;

    // canvas zoom
    var nc_canvas_zoom_level_index = NC_CANVAS_DEFAULT_ZOOM_LEVEL_INDEX; // 1.0
    var nc_canvas_scale_without_zoom = 1.0;

    // state of the application
    var nc_is_user_drawing_region = false;
    var nc_is_window_resized = false;
    var nc_is_user_resizing_region = false;
    var nc_is_user_moving_region = false;
    var nc_is_user_drawing_polygon = false;
    var nc_is_region_selected = false;
    var nc_is_all_region_selected = false;
    var nc_is_loaded_img_list_visible = false;
    var nc_is_canvas_zoomed = false;
    var nc_is_loading_current_image = false;
    var nc_is_region_id_visible = true;
    var nc_is_region_boundary_visible = true;
    var nc_is_region_info_visible = false;
    var nc_is_ctrl_pressed = false;

    // region
    var nc_current_shape = NC_REGION_SHAPE.RECT;
    var nc_current_polygon_region_id = -1;
    var nc_user_sel_region_id = -1;
    var nc_click_x0 = 0;
    var nc_click_y0 = 0;
    var nc_click_x1 = 0;
    var nc_click_y1 = 0;
    var nc_region_click_x, nc_region_click_y;
    var nc_region_edge = [-1, -1];
    var nc_current_x = 0;
    var nc_current_y = 0;

    // region copy/paste
    var nc_region_selected_flag = []; // region select flag for current image
    var nc_copied_image_regions = [];

    // message
    var nc_message_clear_timer;

    // invoke a method after receiving user input
    var nc_user_input_ok_handler = null;
    var nc_user_input_cancel_handler = null;
    var nc_user_input_data = {};

    // annotation editor
    var nc_annotaion_editor_panel = document.getElementById('annotation_editor_panel');

    // all the image_id and image_filename of images added by the user is
    // stored in nc_image_id_list and nc_image_filename_list
    //
    // Image filename list (img_fn_list) contains a filtered list of images
    // currently accessible by the user. The img_fn_list is visible in the
    // left side toolbar. image_grid, next/prev, etc operations depend on
    // the contents of nc_img_fn_list_img_index_list.

    var nc_image_id_list = []; // array of all image id (in order they were added by user)
    var nc_image_filename_list = []; // array of all image filename
    var nc_image_load_error = []; // {true, false}
    var nc_img_fn_list_html = []; // html representation of image filename list
    var nc_img_fn_list_img_index_list = [];

    // image grid
    var image_grid_panel = document.getElementById('image_grid_panel');
    var nc_display_area_content_name = ''; // describes what is currently shown in display area
    var nc_display_area_content_name_prev = '';

    var nc_image_grid_load_ongoing = false;
    var nc_image_grid_page_first_index = 0; // array index in nc_img_fn_list_img_index_list[]
    var nc_image_grid_page_last_index = -1;
    var nc_image_grid_selected_img_index_list = [];
    var nc_image_grid_page_img_index_list = []; // list of all image index in current page of image grid
    var nc_image_grid_visible_img_index_list = []; // list of images currently visible in grid
    var nc_image_grid_mousedown_img_index = -1;
    var nc_image_grid_mouseup_img_index = -1;
    var nc_image_grid_img_index_list = []; // list of all image index in the image grid
    var nc_image_grid_region_index_list = []; // list of all image index in the image grid
    var nc_image_grid_group = {}; // {'value':[image_index_list]}
    var nc_image_grid_group_var = []; // {type, name, value}
    var nc_image_grid_group_show_all = false;
    var nc_image_grid_stack_prev_page = []; // stack of first img index of every page navigated so far

    // image buffer
    var NC_IMG_PRELOAD_INDICES = [1, -1, 2, 3, -2, 4]; // for any image, preload previous 2 and next 4 images
    var NC_IMG_PRELOAD_COUNT = 4;
    var nc_buffer_preload_img_index = -1;
    var nc_buffer_img_index_list = [];
    var nc_buffer_img_shown_timestamp = [];
    var nc_preload_img_promise_list = [];

    // nc settings
    var nc_settings = {};
    nc_settings.ui = {};
    nc_settings.ui.leftsidebar_width = 18; // in rem

    nc_settings.ui.image_grid = {};
    nc_settings.ui.image_grid.img_height = 80; // in pixel
    nc_settings.ui.image_grid.show_image_policy = 'all';

    nc_settings.ui.image = {};
    nc_settings.ui.image.region_label = 'id'; // default: region_id
    nc_settings.ui.image.region_color = '#ffff00'; // default color
    nc_settings.ui.image.region_label_font = '10px Sans';

    nc_settings.core = {};
    nc_settings.core.buffer_size = 4 * NC_IMG_PRELOAD_COUNT + 2;
    nc_settings.core.default_filepath = '';

    nc_settings.core.default_labels = 'bg,fg';

    // UI html elements
    var invisible_file_input = document.getElementById("invisible_file_input");
    var display_area = document.getElementById("display_area");
    var ui_top_panel = document.getElementById("ui_top_panel");
    var image_panel = document.getElementById("image_panel");
    var img_buffer_now = document.getElementById("img_buffer_now");


    var file_list_panel = document.getElementById('file_list_panel');
    var img_fn_list = document.getElementById('img_fn_list');
    var leftsidebar = document.getElementById('leftsidebar');

    var NC_IMAGE_GRID_IMG_HEIGHT_CHANGE = 20; // in percent
    var NC_LEFTSIDEBAR_WIDTH_CHANGE = 1; // in rem
    var NC_FLOAT_PRECISION = 3; // number of decimal places to include in float values

    // Data structure to store metadata about file and regions
    function file_metadata(filename, size) {
        this.filename = filename;
        this.size = size; // file size in bytes
        this.regions = []; // array of file_region()
    }

    function file_region() {
        this.attributes = {}; // shape attributes
    }

    function get_default_value(v, dv) {
        return (typeof(v) === "undefined") ? dv : v;
    }

    // Initialization routine
    function nc_init() {
        console.log(NC_NAME);
        show_message(NC_NAME + ' version ' + NC_VERSION + '. Ready !', 2 * NC_THEME_MESSAGE_TIMEOUT_MS);

        document.getElementById('img_fn_list').style.display = 'block';
        document.getElementById('leftsidebar').style.display = 'table-cell';

        // initialize default project
        project_init_default_project();

        // initialize region canvas 2D context
        nc_init_reg_canvas_context();

        // initialize user input handlers (for both window and nc_reg_canvas)
        // handles drawing of regions by user over the image
        nc_init_keyboard_handlers();
        nc_init_mouse_handlers();

        // initialize image grid
        image_grid_init();

        view_single_image();
        init_leftsidebar_accordion();
        init_message_panel();

        refresh_region_color_picker();

        nc_quit();
    }

    function nc_quit() {
        // warn user of possible loss of data
        window.onbeforeunload = function(e) {
            e = e || window.event;
            // For IE and Firefox prior to version 4
            if (e) { e.returnValue = 'Did you save your data?'; }
            // For Safari
            return 'Did you save your data?';
        };
    }

    function nc_init_reg_canvas_context() {
        nc_reg_ctx = nc_reg_canvas.getContext('2d');
    }

    function nc_init_keyboard_handlers() {
        window.addEventListener('keydown', nc_window_keydown_handler, false);

        nc_reg_canvas.addEventListener('keydown', nc_reg_canvas_keydown_handler, false);
        nc_reg_canvas.addEventListener('keyup', nc_reg_canvas_keyup_handler, false);
    }

    // handles drawing of regions over image by the user
    function nc_init_mouse_handlers() {
        nc_reg_canvas.addEventListener('dblclick', nc_reg_canvas_dblclick_handler, false);
        nc_reg_canvas.addEventListener('mousedown', nc_reg_canvas_mousedown_handler, false);
        nc_reg_canvas.addEventListener('mouseup', nc_reg_canvas_mouseup_handler, false);
        nc_reg_canvas.addEventListener('mouseover', nc_reg_canvas_mouseover_handler, false);
        nc_reg_canvas.addEventListener('mousemove', nc_reg_canvas_mousemove_handler, false);
        nc_reg_canvas.addEventListener('wheel', nc_reg_canvas_mouse_wheel_listener, false);
        // touch screen event handlers
        // @todo: adapt for mobile users
        nc_reg_canvas.addEventListener('touchstart', nc_reg_canvas_mousedown_handler, false);
        nc_reg_canvas.addEventListener('touchend', nc_reg_canvas_mouseup_handler, false);
        nc_reg_canvas.addEventListener('touchmove', nc_reg_canvas_mousemove_handler, false);
    }

    function select_color(value) {
        nc_settings.ui.image.region_color = value;
    }

    function download_as_image() {
        if (nc_display_area_content_name !== NC_DISPLAY_AREA_CONTENT_NAME['IMAGE']) {
            show_message('This functionality is only available in single image view mode');
            return;
        }
        var c = document.createElement('canvas');

        // ensures that downloaded image is scaled at current zoom level
        c.width = nc_reg_canvas.width;
        c.height = nc_reg_canvas.height;

        var ct = c.getContext('2d');
        // draw current image
        ct.drawImage(nc_current_image, 0, 0, nc_reg_canvas.width, nc_reg_canvas.height);
        // draw current regions
        ct.drawImage(nc_reg_canvas, 0, 0);

        var cur_img_mime = 'image/jpeg';
        if (nc_current_image.src.startsWith('data:')) {
            var c1 = nc_current_image.src.indexOf(':', 0);
            var c2 = nc_current_image.src.indexOf(';', c1);
            cur_img_mime = nc_current_image.src.substring(c1 + 1, c2);
        }

        // extract image data from canvas
        var saved_img = c.toDataURL(cur_img_mime);
        saved_img.replace(cur_img_mime, "image/octet-stream");

        // simulate user click to trigger download of image
        var a = document.createElement('a');
        a.href = saved_img;
        a.target = '_blank';
        a.download = nc_current_image_filename;

        // simulate a mouse click event
        var event = new MouseEvent('click', {
            view: window,
            bubbles: true,
            cancelable: true
        });

        a.dispatchEvent(event);
    }

    // Display area content
    function clear_display_area() {
        var panels = document.getElementsByClassName('display_area_content');
        for (var i = 0; i < panels.length; ++i) {
            panels[i].classList.add('display_none');
        }
    }

    function is_content_name_valid(content_name) {
        for (var e in NC_DISPLAY_AREA_CONTENT_NAME) {
            if (NC_DISPLAY_AREA_CONTENT_NAME[e] === content_name) { return true; }
        }
        return false;
    }

    function show_home_panel() {
        view_single_image();
    }

    function set_display_area_content(content_name) {
        if (is_content_name_valid(content_name)) {
            nc_display_area_content_name_prev = nc_display_area_content_name;
            clear_display_area();
            var p = document.getElementById(content_name);
            p.classList.remove('display_none');
            nc_display_area_content_name = content_name;
        }
    }

    function view_single_image() {
        if (nc_current_image_loaded) {
            file_list_clear_all_style();
            nc_show_image(nc_image_index);
            set_display_area_content(NC_DISPLAY_AREA_CONTENT_NAME.IMAGE);
        } else {
            set_display_area_content(NC_DISPLAY_AREA_CONTENT_NAME.PAGE_START_INFO);
        }
    }

    function view_grid_images() {
        if (nc_current_image_loaded) {
            file_list_clear_all_style();
            set_display_area_content(NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID);
            image_grid_toolbar_update_group_by_select();

            if (nc_image_grid_group_var.length === 0) {
                image_grid_show_all_images();
            }
        } else {
            set_display_area_content(NC_DISPLAY_AREA_CONTENT_NAME.PAGE_START_INFO);
        }
    }

    // Handlers for top navigation bar
    function project_add_files() {
        // source: https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications
        if (invisible_file_input) {
            invisible_file_input.setAttribute('multiple', 'multiple');
            invisible_file_input.accept = '.jpg,.jpeg,.png,.bmp';
            invisible_file_input.onchange = project_file_add_local;
            invisible_file_input.click();
        }
    }

    // ensure the exported json string conforms to RFC 4180
    // see: https://en.wikipedia.org/wiki/Comma-separated_values
    function map_to_json(m) {
        var s = [];
        for (var key in m) {
            var v = m[key];
            var si = JSON.stringify(key);
            si += NC_CSV_KEYVAL_SEP;
            si += JSON.stringify(v);
            s.push(si);
        }
        return '{' + s.join(NC_CSV_SEP) + '}';
    }

    function escape_for_csv(s) {
        return s.replace(/["]/g, '""');
    }

    function clone_image_region(r0) {
        var r1 = new file_region();
        // copy shape attributes
        for (var key in r0.attributes) {
            r1.attributes[key] = clone_value(r0.attributes[key]);
        }
        return r1;
    }

    function clone_value(value) {
        if (typeof(value) === 'object') {
            if (Array.isArray(value)) {
                return value.slice(0);
            } else {
                var copy = {};
                for (var p in value) {
                    if (value.hasOwnProperty(p)) {
                        copy[p] = clone_value(value[p]);
                    }
                }
                return copy;
            }
        }
        return value;
    }

    function nc_get_image_id(filename, size) {
        if (typeof(size) === 'undefined') {
            return filename;
        } else {
            return filename + size;
        }
    }

    function load_text_file(text_file, callback_function) {
        if (text_file) {
            var text_reader = new FileReader();
            text_reader.addEventListener('progress', function(e) {
                show_message('Loading data from file : ' + text_file.name + ' ... ');
            }, false);

            text_reader.addEventListener('error', function() {
                show_message('Error loading data text file :  ' + text_file.name + ' !');
                callback_function('');
            }, false);

            text_reader.addEventListener('load', function() {
                callback_function(text_reader.result);
            }, false);
            text_reader.readAsText(text_file, 'utf-8');
        }
    }

    // Data Exporter
    function packnc_metadata(return_type) {
        return new Promise(function(ok_callback, err_callback) {
            if (return_type === 'csv') {
                var csvdata = [];
                var csvheader = 'filename,file_size,region_count,region_id,region_shape_attributes';
                csvdata.push(csvheader);

                for (var image_id in nc_image_metadata) {
                    var prefix = '\n' + nc_image_metadata[image_id].filename;
                    prefix += ',' + nc_image_metadata[image_id].size;

                    var r = nc_image_metadata[image_id].regions;

                    if (r.length !== 0) {
                        for (var i = 0; i < r.length; ++i) {
                            var csvline = [];
                            csvline.push(prefix);
                            csvline.push(r.length);
                            csvline.push(i);

                            var sattr = map_to_json(r[i].attributes);
                            sattr = '"' + escape_for_csv(sattr) + '"';
                            csvline.push(sattr);

                            csvdata.push(csvline.join(NC_CSV_SEP));
                        }
                    } else {
                        // @todo: reconsider this practice of adding an empty entry
                        csvdata.push(prefix + ',0,0,"{}","{}"');
                    }
                }
                ok_callback(csvdata);
            }

            // default format is JSON
            ok_callback([JSON.stringify(nc_image_metadata)]);
        }.bind(this));
    }

    function save_data_to_local_file(data, filename) {
        var a = document.createElement('a');
        a.href = URL.createObjectURL(data);
        a.download = filename;

        // simulate a mouse click event
        var event = new MouseEvent('click', {
            view: window,
            bubbles: true,
            cancelable: true
        });
        a.dispatchEvent(event);

        // @todo: replace a.dispatchEvent() with a.click()
        // a.click() based trigger is supported in Chrome 70 and Safari 11/12 but **not** in Firefox 63
        //a.click();
    }

    // Maintainers of user interface
    function init_message_panel() {
        var p = document.getElementById('message_panel');
        p.addEventListener('mousedown', function() {
            this.style.display = 'none';
        }, false);
        p.addEventListener('mouseover', function() {
            clearTimeout(nc_message_clear_timer); // stop any previous timeouts
        }, false);
    }

    function show_message(msg, t) {
        if (nc_message_clear_timer) {
            clearTimeout(nc_message_clear_timer); // stop any previous timeouts
        }
        var timeout = get_default_value(t, NC_THEME_MESSAGE_TIMEOUT_MS);
        document.getElementById('message_panel_content').innerHTML = msg;
        document.getElementById('message_panel').style.display = 'block';

        nc_message_clear_timer = setTimeout(function() {
            document.getElementById('message_panel').style.display = 'none';
        }, timeout);
    }

    // transform regions in image space to canvas space
    function nc_load_canvas_regions() {
        // load all existing annotations into nc_canvas_regions
        var regions = nc_image_metadata[nc_image_id].regions;
        nc_canvas_regions = [];
        for (var i = 0; i < regions.length; ++i) {
            var region_i = new file_region();
            for (var key in regions[i].attributes) {
                region_i.attributes[key] = regions[i].attributes[key];
            }
            nc_canvas_regions.push(region_i);

            switch (nc_canvas_regions[i].attributes['name']) {
                case NC_REGION_SHAPE.RECT:
                    var x = regions[i].attributes['x'] / nc_canvas_scale;
                    var y = regions[i].attributes['y'] / nc_canvas_scale;
                    var width = regions[i].attributes['width'] / nc_canvas_scale;
                    var height = regions[i].attributes['height'] / nc_canvas_scale;

                    nc_canvas_regions[i].attributes['x'] = Math.round(x);
                    nc_canvas_regions[i].attributes['y'] = Math.round(y);
                    nc_canvas_regions[i].attributes['width'] = Math.round(width);
                    nc_canvas_regions[i].attributes['height'] = Math.round(height);
                    break;

                case NC_REGION_SHAPE.CIRCLE:
                    var cx = regions[i].attributes['cx'] / nc_canvas_scale;
                    var cy = regions[i].attributes['cy'] / nc_canvas_scale;
                    var r = regions[i].attributes['r'] / nc_canvas_scale;
                    nc_canvas_regions[i].attributes['cx'] = Math.round(cx);
                    nc_canvas_regions[i].attributes['cy'] = Math.round(cy);
                    nc_canvas_regions[i].attributes['r'] = Math.round(r);
                    break;

                case NC_REGION_SHAPE.ELLIPSE:
                    var cx = regions[i].attributes['cx'] / nc_canvas_scale;
                    var cy = regions[i].attributes['cy'] / nc_canvas_scale;
                    var rx = regions[i].attributes['rx'] / nc_canvas_scale;
                    var ry = regions[i].attributes['ry'] / nc_canvas_scale;
                    // rotation in radians
                    var theta = regions[i].attributes['theta'];
                    nc_canvas_regions[i].attributes['cx'] = Math.round(cx);
                    nc_canvas_regions[i].attributes['cy'] = Math.round(cy);
                    nc_canvas_regions[i].attributes['rx'] = Math.round(rx);
                    nc_canvas_regions[i].attributes['ry'] = Math.round(ry);
                    nc_canvas_regions[i].attributes['theta'] = theta;
                    break;

                case NC_REGION_SHAPE.POLYLINE: // handled by polygon
                case NC_REGION_SHAPE.POLYGON:
                    var all_points_x = regions[i].attributes['all_points_x'].slice(0);
                    var all_points_y = regions[i].attributes['all_points_y'].slice(0);
                    for (var j = 0; j < all_points_x.length; ++j) {
                        all_points_x[j] = Math.round(all_points_x[j] / nc_canvas_scale);
                        all_points_y[j] = Math.round(all_points_y[j] / nc_canvas_scale);
                    }
                    nc_canvas_regions[i].attributes['all_points_x'] = all_points_x;
                    nc_canvas_regions[i].attributes['all_points_y'] = all_points_y;
                    break;

                case NC_REGION_SHAPE.POINT:
                    var cx = regions[i].attributes['cx'] / nc_canvas_scale;
                    var cy = regions[i].attributes['cy'] / nc_canvas_scale;

                    nc_canvas_regions[i].attributes['cx'] = Math.round(cx);
                    nc_canvas_regions[i].attributes['cy'] = Math.round(cy);
                    break;
            }
        }
    }

    function select_shape(sel_shape_name) {
        for (var shape_name in NC_REGION_SHAPE) {
            var ui_element = document.getElementById('region_shape_' + NC_REGION_SHAPE[shape_name]);
            ui_element.classList.remove('selected');
        }

        nc_current_shape = sel_shape_name;
        var ui_element = document.getElementById('region_shape_' + nc_current_shape);
        ui_element.classList.add('selected');

        switch (nc_current_shape) {
            case NC_REGION_SHAPE.RECT: // Fall-through
            case NC_REGION_SHAPE.CIRCLE: // Fall-through
            case NC_REGION_SHAPE.ELLIPSE:
                show_message('[Click] and drag mouse to draw ' + nc_current_shape);
                break;

            case NC_REGION_SHAPE.POLYLINE:
            case NC_REGION_SHAPE.POLYGON:
                nc_is_user_drawing_polygon = false;
                nc_current_polygon_region_id = -1;
                show_message('[Click] define polygon/polyline vertices, [Backspace] delete last vertex, [Enter] finish, [Esc] cancel.');
                break;

            case NC_REGION_SHAPE.POINT:
                show_message('[Click] define points (or landmarks)');
                break;

            default:
                show_message('Unknown shape selected!');
                break;
        }
    }

    function set_canvas_size(w, h) {
        nc_reg_canvas.height = h;
        nc_reg_canvas.width = w;

        image_panel.style.height = h + 'px';
        image_panel.style.width = w + 'px';
    }

    function jump_to_image(image_index) {
        if (nc_image_count <= 0) {
            return;
        }

        switch (nc_display_area_content_name) {
            case NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID:
                if (image_index >= 0 && image_index < nc_image_count) {
                    // @todo: jump to image grid page view with the given first image index
                    view_single_image();
                    nc_show_image(image_index);
                }
                break;
            default:
                if (image_index >= 0 && image_index < nc_image_count) {
                    nc_show_image(image_index);
                }
                break;
        }
    }

    function toggle_all_regions_selection(is_selected) {
        var n = nc_image_metadata[nc_image_id].regions.length;
        var i;
        nc_region_selected_flag = [];
        for (i = 0; i < n; ++i) {
            nc_region_selected_flag[i] = is_selected;
        }
        nc_is_all_region_selected = is_selected;
    }

    function select_only_region(region_id) {
        toggle_all_regions_selection(false);
        set_region_select_state(region_id, true);
        nc_is_region_selected = true;
        nc_is_all_region_selected = false;
        nc_user_sel_region_id = region_id;
    }

    function set_region_select_state(region_id, is_selected) {
        nc_region_selected_flag[region_id] = is_selected;
    }

    function show_annotation_data() {
        packnc_metadata('csv').then(function(data) {
            var hstr = '<pre>' + data.join('') + '</pre>';
            var window_features = 'toolbar=no,menubar=no,location=no,resizable=yes,scrollbars=yes,status=no';
            window_features += ',width=800,height=600';
            var annotation_data_window = window.open('', 'Annotations (preview) ', window_features);
            annotation_data_window.document.body.innerHTML = hstr;
        }.bind(this), function(err) {
            show_message('Failed to collect annotation data!');
        }.bind(this));
    }

    // enter annotation mode on double click
    function nc_reg_canvas_dblclick_handler(e) {
        e.stopPropagation();
        // xxxx9999
        // @todo: use double click in future
    }

    // user clicks on the canvas, mousedown
    function nc_reg_canvas_mousedown_handler(e) {
        e.stopPropagation();
        nc_click_x0 = e.offsetX;
        nc_click_y0 = e.offsetY;
        nc_region_edge = is_on_region_corner(nc_click_x0, nc_click_y0);
        var region_id = is_inside_region(nc_click_x0, nc_click_y0);

        if (nc_is_region_selected) {
            // check if user clicked on the region boundary
            if (nc_region_edge[1] > 0) {
                if (!nc_is_user_resizing_region) {
                    if (nc_region_edge[0] !== nc_user_sel_region_id) {
                        nc_user_sel_region_id = nc_region_edge[0];
                    }
                    // resize region
                    nc_is_user_resizing_region = true;
                }
            } else {
                var yes = is_inside_this_region(nc_click_x0, nc_click_y0, nc_user_sel_region_id);
                if (yes) {
                    if (!nc_is_user_moving_region) {
                        nc_is_user_moving_region = true;
                        nc_region_click_x = nc_click_x0;
                        nc_region_click_y = nc_click_y0;
                    }
                }
                if (region_id === -1) {
                    // mousedown on outside any region
                    nc_is_user_drawing_region = true;

                    // unselect all regions
                    nc_is_region_selected = false;
                    nc_user_sel_region_id = -1;
                    toggle_all_regions_selection(false);
                }
            }
        } else {
            if (region_id === -1) {
                // mousedown outside a region
                if (nc_current_shape !== NC_REGION_SHAPE.POLYGON &&
                    nc_current_shape !== NC_REGION_SHAPE.POLYLINE &&
                    nc_current_shape !== NC_REGION_SHAPE.POINT) {
                    // this is a bounding box drawing event
                    nc_is_user_drawing_region = true;
                }
            } else {
                // mousedown inside a region
                // this could lead to (1) region selection or (2) region drawing
                nc_is_user_drawing_region = true;
            }
        }

        if (nc_is_user_drawing_region) {
            annotation_editor_hide();
        }
    }

    // implements the following functionalities:
    //  - new region drawing (including polygon)
    //  - moving/resizing/select/unselect existing region
    function nc_reg_canvas_mouseup_handler(e) {
        e.stopPropagation();
        nc_click_x1 = e.offsetX;
        nc_click_y1 = e.offsetY;

        var click_dx = Math.abs(nc_click_x1 - nc_click_x0);
        var click_dy = Math.abs(nc_click_y1 - nc_click_y0);

        // indicates that user has finished moving a region
        if (nc_is_user_moving_region) {
            nc_is_user_moving_region = false;
            nc_reg_canvas.style.cursor = "default";

            var move_x = Math.round(nc_click_x1 - nc_region_click_x);
            var move_y = Math.round(nc_click_y1 - nc_region_click_y);

            if (Math.abs(move_x) > NC_MOUSE_CLICK_TOL ||
                Math.abs(move_y) > NC_MOUSE_CLICK_TOL) {
                // move all selected regions
                nc_move_selected_regions(move_x, move_y);
            } else {
                // indicates a user click on an already selected region
                // this could indicate the user's intention to select another
                // nested region within this region
                // OR
                // draw a nested region (i.e. region inside a region)

                // traverse the canvas regions in alternating ascending
                // and descending order to solve the issue of nested regions
                var nested_region_id = is_inside_region(nc_click_x0, nc_click_y0, true);
                if (nested_region_id >= 0 &&
                    nested_region_id !== nc_user_sel_region_id) {
                    nc_user_sel_region_id = nested_region_id;
                    nc_is_region_selected = true;
                    nc_is_user_moving_region = false;

                    // de-select all other regions if the user has not pressed Shift
                    if (!e.shiftKey) {
                        toggle_all_regions_selection(false);
                    }
                    set_region_select_state(nested_region_id, true);
                    annotation_editor_show();
                } else {
                    // user clicking inside an already selected region
                    // indicates that the user intends to draw a nested region
                    toggle_all_regions_selection(false);
                    nc_is_region_selected = false;

                    switch (nc_current_shape) {
                        case NC_REGION_SHAPE.POLYLINE: // handled by case for POLYGON
                        case NC_REGION_SHAPE.POLYGON:
                            // user has clicked on the first point in a new polygon
                            // see also event 'mouseup' for nc_is_user_drawing_polygon=true
                            nc_is_user_drawing_polygon = true;

                            var canvas_polygon_region = new file_region();
                            canvas_polygon_region.attributes['name'] = nc_current_shape;
                            canvas_polygon_region.attributes['all_points_x'] = [Math.round(nc_click_x0)];
                            canvas_polygon_region.attributes['all_points_y'] = [Math.round(nc_click_y0)];
                            var new_length = nc_canvas_regions.push(canvas_polygon_region);
                            nc_current_polygon_region_id = new_length - 1;
                            break;

                        case NC_REGION_SHAPE.POINT:
                            // user has marked a landmark point
                            var point_region = new file_region();
                            point_region.attributes['name'] = NC_REGION_SHAPE.POINT;
                            point_region.attributes['cx'] = Math.round(nc_click_x0 * nc_canvas_scale);
                            point_region.attributes['cy'] = Math.round(nc_click_y0 * nc_canvas_scale);
                            nc_image_metadata[nc_image_id].regions.push(point_region);

                            var canvas_point_region = new file_region();
                            canvas_point_region.attributes['name'] = NC_REGION_SHAPE.POINT;
                            canvas_point_region.attributes['cx'] = Math.round(nc_click_x0);
                            canvas_point_region.attributes['cy'] = Math.round(nc_click_y0);
                            nc_canvas_regions.push(canvas_point_region);
                            break;
                    }
                }
            }
            nc_redraw_reg_canvas();
            nc_reg_canvas.focus();
            return;
        }

        // indicates that user has finished resizing a region
        if (nc_is_user_resizing_region) {
            // nc_click(x0,y0) to nc_click(x1,y1)
            nc_is_user_resizing_region = false;
            nc_reg_canvas.style.cursor = "default";

            // update the region
            var region_id = nc_region_edge[0];
            var image_attr = nc_image_metadata[nc_image_id].regions[region_id].attributes;
            var canvas_attr = nc_canvas_regions[region_id].attributes;

            switch (canvas_attr['name']) {
                case NC_REGION_SHAPE.RECT:
                    var d = [canvas_attr['x'], canvas_attr['y'], 0, 0];
                    d[2] = d[0] + canvas_attr['width'];
                    d[3] = d[1] + canvas_attr['height'];

                    var mx = nc_current_x;
                    var my = nc_current_y;
                    var preserve_aspect_ratio = false;

                    // constrain (mx,my) to lie on a line connecting a diagonal of rectangle
                    if (nc_is_ctrl_pressed) {
                        preserve_aspect_ratio = true;
                    }

                    rect_update_corner(nc_region_edge[1], d, mx, my, preserve_aspect_ratio);
                    rect_standardize_coordinates(d);

                    var w = Math.abs(d[2] - d[0]);
                    var h = Math.abs(d[3] - d[1]);

                    image_attr['x'] = Math.round(d[0] * nc_canvas_scale);
                    image_attr['y'] = Math.round(d[1] * nc_canvas_scale);
                    image_attr['width'] = Math.round(w * nc_canvas_scale);
                    image_attr['height'] = Math.round(h * nc_canvas_scale);

                    canvas_attr['x'] = Math.round(image_attr['x'] / nc_canvas_scale);
                    canvas_attr['y'] = Math.round(image_attr['y'] / nc_canvas_scale);
                    canvas_attr['width'] = Math.round(image_attr['width'] / nc_canvas_scale);
                    canvas_attr['height'] = Math.round(image_attr['height'] / nc_canvas_scale);
                    break;

                case NC_REGION_SHAPE.CIRCLE:
                    var dx = Math.abs(canvas_attr['cx'] - nc_current_x);
                    var dy = Math.abs(canvas_attr['cy'] - nc_current_y);
                    var new_r = Math.sqrt(dx * dx + dy * dy);

                    image_attr['r'] = fixfloat(new_r * nc_canvas_scale);
                    canvas_attr['r'] = Math.round(image_attr['r'] / nc_canvas_scale);
                    break;

                case NC_REGION_SHAPE.ELLIPSE:
                    var new_rx = canvas_attr['rx'];
                    var new_ry = canvas_attr['ry'];
                    var new_theta = canvas_attr['theta'];
                    var dx = Math.abs(canvas_attr['cx'] - nc_current_x);
                    var dy = Math.abs(canvas_attr['cy'] - nc_current_y);

                    switch (nc_region_edge[1]) {
                        case 5:
                            new_ry = Math.sqrt(dx * dx + dy * dy);
                            new_theta = Math.atan2(-(nc_current_x - canvas_attr['cx']), (nc_current_y - canvas_attr['cy']));
                            break;

                        case 6:
                            new_rx = Math.sqrt(dx * dx + dy * dy);
                            new_theta = Math.atan2((nc_current_y - canvas_attr['cy']), (nc_current_x - canvas_attr['cx']));
                            break;

                        default:
                            new_rx = dx;
                            new_ry = dy;
                            new_theta = 0;
                            break;
                    }

                    image_attr['rx'] = fixfloat(new_rx * nc_canvas_scale);
                    image_attr['ry'] = fixfloat(new_ry * nc_canvas_scale);
                    image_attr['theta'] = fixfloat(new_theta);

                    canvas_attr['rx'] = Math.round(image_attr['rx'] / nc_canvas_scale);
                    canvas_attr['ry'] = Math.round(image_attr['ry'] / nc_canvas_scale);
                    canvas_attr['theta'] = fixfloat(new_theta);
                    break;

                case NC_REGION_SHAPE.POLYLINE: // handled by polygon
                case NC_REGION_SHAPE.POLYGON:
                    var moved_vertex_id = nc_region_edge[1] - NC_POLYGON_RESIZE_VERTEX_OFFSET;

                    if (e.ctrlKey) {
                        // if on vertex, delete it
                        // if on edge, add a new vertex
                        var r = nc_canvas_regions[nc_user_sel_region_id].attributes;
                        var shape = r.name;
                        var is_on_vertex = is_on_polygon_vertex(r['all_points_x'], r['all_points_y'], nc_current_x, nc_current_y);

                        if (is_on_vertex === nc_region_edge[1]) {
                            // click on vertex, hence delete vertex
                            if (nc_polygon_del_vertex(region_id, moved_vertex_id)) {
                                show_message('Deleted vertex ' + moved_vertex_id + ' from region');
                            }
                        } else {
                            var is_on_edge = is_on_polygon_edge(r['all_points_x'], r['all_points_y'], nc_current_x, nc_current_y);
                            if (is_on_edge === nc_region_edge[1]) {
                                // click on edge, hence add new vertex
                                var vertex_index = is_on_edge - NC_POLYGON_RESIZE_VERTEX_OFFSET;
                                var canvas_x0 = Math.round(nc_click_x1);
                                var canvas_y0 = Math.round(nc_click_y1);
                                var img_x0 = Math.round(canvas_x0 * nc_canvas_scale);
                                var img_y0 = Math.round(canvas_y0 * nc_canvas_scale);
                                canvas_x0 = Math.round(img_x0 / nc_canvas_scale);
                                canvas_y0 = Math.round(img_y0 / nc_canvas_scale);

                                nc_canvas_regions[region_id].attributes['all_points_x'].splice(vertex_index + 1, 0, canvas_x0);
                                nc_canvas_regions[region_id].attributes['all_points_y'].splice(vertex_index + 1, 0, canvas_y0);
                                nc_image_metadata[nc_image_id].regions[region_id].attributes['all_points_x'].splice(vertex_index + 1, 0, img_x0);
                                nc_image_metadata[nc_image_id].regions[region_id].attributes['all_points_y'].splice(vertex_index + 1, 0, img_y0);

                                show_message('Added 1 new vertex to ' + shape + ' region');
                            }
                        }
                    } else {
                        // update coordinate of vertex
                        var imx = Math.round(nc_current_x * nc_canvas_scale);
                        var imy = Math.round(nc_current_y * nc_canvas_scale);
                        image_attr['all_points_x'][moved_vertex_id] = imx;
                        image_attr['all_points_y'][moved_vertex_id] = imy;
                        canvas_attr['all_points_x'][moved_vertex_id] = Math.round(imx / nc_canvas_scale);
                        canvas_attr['all_points_y'][moved_vertex_id] = Math.round(imy / nc_canvas_scale);
                    }
                    break;
            } // end of switch()
            nc_redraw_reg_canvas();
            nc_reg_canvas.focus();
            return;
        }

        // denotes a single click (= mouse down + mouse up)
        if (click_dx < NC_MOUSE_CLICK_TOL ||
            click_dy < NC_MOUSE_CLICK_TOL) {
            // if user is already drawing polygon, then each click adds a new point
            if (nc_is_user_drawing_polygon) {
                var canvas_x0 = Math.round(nc_click_x1);
                var canvas_y0 = Math.round(nc_click_y1);
                var n = nc_canvas_regions[nc_current_polygon_region_id].attributes['all_points_x'].length;
                var last_x0 = nc_canvas_regions[nc_current_polygon_region_id].attributes['all_points_x'][n - 1];
                var last_y0 = nc_canvas_regions[nc_current_polygon_region_id].attributes['all_points_y'][n - 1];
                // discard if the click was on the last vertex
                if (canvas_x0 !== last_x0 || canvas_y0 !== last_y0) {
                    // user clicked on a new polygon point
                    nc_canvas_regions[nc_current_polygon_region_id].attributes['all_points_x'].push(canvas_x0);
                    nc_canvas_regions[nc_current_polygon_region_id].attributes['all_points_y'].push(canvas_y0);
                }
            } else {
                var region_id = is_inside_region(nc_click_x0, nc_click_y0);
                if (region_id >= 0) {
                    // first click selects region
                    nc_user_sel_region_id = region_id;
                    nc_is_region_selected = true;
                    nc_is_user_moving_region = false;
                    nc_is_user_drawing_region = false;

                    // de-select all other regions if the user has not pressed Shift
                    if (!e.shiftKey) {
                        toggle_all_regions_selection(false);
                    }
                    set_region_select_state(region_id, true);

                    // show annotation editor only when a single region is selected
                    if (!e.shiftKey) {
                        annotation_editor_show();
                    } else {
                        annotation_editor_hide();
                    }

                    // show the region info
                    if (nc_is_region_info_visible) {
                        var canvas_attr = nc_canvas_regions[region_id].attributes;

                        switch (canvas_attr['name']) {
                            case NC_REGION_SHAPE.RECT:
                                break;

                            case NC_REGION_SHAPE.CIRCLE:
                                var rf = document.getElementById('region_info');
                                var attr = nc_canvas_regions[nc_user_sel_region_id].attributes;
                                rf.innerHTML += ',' + ' Radius:' + attr['r'];
                                break;

                            case NC_REGION_SHAPE.ELLIPSE:
                                var rf = document.getElementById('region_info');
                                var attr = nc_canvas_regions[nc_user_sel_region_id].attributes;
                                rf.innerHTML += ',' + ' X-radius:' + attr['rx'] + ',' + ' Y-radius:' + attr['ry'];
                                break;

                            case NC_REGION_SHAPE.POLYLINE:
                            case NC_REGION_SHAPE.POLYGON:
                                break;
                        }
                    }

                    show_message('Region selected. If you intended to draw a region, click again inside the selected region to start drawing a region.')
                } else {
                    if (nc_is_user_drawing_region) {
                        // clear all region selection
                        nc_is_user_drawing_region = false;
                        nc_is_region_selected = false;
                        toggle_all_regions_selection(false);
                    } else {
                        switch (nc_current_shape) {
                            case NC_REGION_SHAPE.POLYLINE: // handled by case for POLYGON
                            case NC_REGION_SHAPE.POLYGON:
                                // user has clicked on the first point in a new polygon
                                // see also event 'mouseup' for nc_is_user_moving_region=true
                                nc_is_user_drawing_polygon = true;

                                var canvas_polygon_region = new file_region();
                                canvas_polygon_region.attributes['name'] = nc_current_shape;
                                canvas_polygon_region.attributes['all_points_x'] = [Math.round(nc_click_x0)];
                                canvas_polygon_region.attributes['all_points_y'] = [Math.round(nc_click_y0)];

                                var new_length = nc_canvas_regions.push(canvas_polygon_region);
                                nc_current_polygon_region_id = new_length - 1;
                                break;

                            case NC_REGION_SHAPE.POINT:
                                // user has marked a landmark point
                                var point_region = new file_region();
                                point_region.attributes['name'] = NC_REGION_SHAPE.POINT;
                                point_region.attributes['cx'] = Math.round(nc_click_x0 * nc_canvas_scale);
                                point_region.attributes['cy'] = Math.round(nc_click_y0 * nc_canvas_scale);
                                nc_image_metadata[nc_image_id].regions.push(point_region);

                                var canvas_point_region = new file_region();
                                canvas_point_region.attributes['name'] = NC_REGION_SHAPE.POINT;
                                canvas_point_region.attributes['cx'] = Math.round(nc_click_x0);
                                canvas_point_region.attributes['cy'] = Math.round(nc_click_y0);
                                nc_canvas_regions.push(canvas_point_region);

                                break;
                        }
                    }
                    create_annotation_editor_content(); // xxxx1111
                }
            }
            nc_redraw_reg_canvas();
            nc_reg_canvas.focus();
            return;
        }

        // indicates that user has finished drawing a new region
        if (nc_is_user_drawing_region) {
            nc_is_user_drawing_region = false;
            var region_x0 = nc_click_x0;
            var region_y0 = nc_click_y0;
            var region_x1 = nc_click_x1;
            var region_y1 = nc_click_y1;

            var original_img_region = new file_region();
            var canvas_img_region = new file_region();
            var region_dx = Math.abs(region_x1 - region_x0);
            var region_dy = Math.abs(region_y1 - region_y0);
            var new_region_added = false;

            if (region_dx > NC_REGION_MIN_DIM && region_dy > NC_REGION_MIN_DIM) { // avoid regions with 0 dim
                switch (nc_current_shape) {
                    case NC_REGION_SHAPE.RECT:
                        // ensure that (x0,y0) is top-left and (x1,y1) is bottom-right
                        if (nc_click_x0 < nc_click_x1) {
                            region_x0 = nc_click_x0;
                            region_x1 = nc_click_x1;
                        } else {
                            region_x0 = nc_click_x1;
                            region_x1 = nc_click_x0;
                        }

                        if (nc_click_y0 < nc_click_y1) {
                            region_y0 = nc_click_y0;
                            region_y1 = nc_click_y1;
                        } else {
                            region_y0 = nc_click_y1;
                            region_y1 = nc_click_y0;
                        }

                        var x = Math.round(region_x0 * nc_canvas_scale);
                        var y = Math.round(region_y0 * nc_canvas_scale);
                        var width = Math.round(region_dx * nc_canvas_scale);
                        var height = Math.round(region_dy * nc_canvas_scale);
                        original_img_region.attributes['name'] = 'rect';
                        original_img_region.attributes['x'] = x;
                        original_img_region.attributes['y'] = y;
                        original_img_region.attributes['width'] = width;
                        original_img_region.attributes['height'] = height;

                        canvas_img_region.attributes['name'] = 'rect';
                        canvas_img_region.attributes['x'] = Math.round(x / nc_canvas_scale);
                        canvas_img_region.attributes['y'] = Math.round(y / nc_canvas_scale);
                        canvas_img_region.attributes['width'] = Math.round(width / nc_canvas_scale);
                        canvas_img_region.attributes['height'] = Math.round(height / nc_canvas_scale);

                        new_region_added = true;
                        break;

                    case NC_REGION_SHAPE.CIRCLE:
                        var cx = Math.round(region_x0 * nc_canvas_scale);
                        var cy = Math.round(region_y0 * nc_canvas_scale);
                        var r = Math.round(Math.sqrt(region_dx * region_dx + region_dy * region_dy) * nc_canvas_scale);

                        original_img_region.attributes['name'] = 'circle';
                        original_img_region.attributes['cx'] = cx;
                        original_img_region.attributes['cy'] = cy;
                        original_img_region.attributes['r'] = r;

                        canvas_img_region.attributes['name'] = 'circle';
                        canvas_img_region.attributes['cx'] = Math.round(cx / nc_canvas_scale);
                        canvas_img_region.attributes['cy'] = Math.round(cy / nc_canvas_scale);
                        canvas_img_region.attributes['r'] = Math.round(r / nc_canvas_scale);

                        new_region_added = true;
                        break;

                    case NC_REGION_SHAPE.ELLIPSE:
                        var cx = Math.round(region_x0 * nc_canvas_scale);
                        var cy = Math.round(region_y0 * nc_canvas_scale);
                        var rx = Math.round(region_dx * nc_canvas_scale);
                        var ry = Math.round(region_dy * nc_canvas_scale);
                        var theta = 0;

                        original_img_region.attributes['name'] = 'ellipse';
                        original_img_region.attributes['cx'] = cx;
                        original_img_region.attributes['cy'] = cy;
                        original_img_region.attributes['rx'] = rx;
                        original_img_region.attributes['ry'] = ry;
                        original_img_region.attributes['theta'] = theta;

                        canvas_img_region.attributes['name'] = 'ellipse';
                        canvas_img_region.attributes['cx'] = Math.round(cx / nc_canvas_scale);
                        canvas_img_region.attributes['cy'] = Math.round(cy / nc_canvas_scale);
                        canvas_img_region.attributes['rx'] = Math.round(rx / nc_canvas_scale);
                        canvas_img_region.attributes['ry'] = Math.round(ry / nc_canvas_scale);
                        canvas_img_region.attributes['theta'] = theta;

                        new_region_added = true;
                        break;

                    case NC_REGION_SHAPE.POINT: // handled by case NC_REGION_SHAPE.POLYGON
                    case NC_REGION_SHAPE.POLYLINE: // handled by case NC_REGION_SHAPE.POLYGON
                    case NC_REGION_SHAPE.POLYGON:
                        // handled by nc_is_user_drawing_polygon
                        break;
                } // end of switch

                if (new_region_added) {
                    var n1 = nc_image_metadata[nc_image_id].regions.push(original_img_region);
                    var n2 = nc_canvas_regions.push(canvas_img_region);

                    if (n1 !== n2) {
                        console.log('nc_image_metadata.regions[' + n1 + '] and nc_canvas_regions[' + n2 + '] count mismatch');
                    }
                    var new_region_id = n1 - 1;

                    select_only_region(new_region_id);

                    annotation_editor_show();
                }
                nc_redraw_reg_canvas();
                nc_reg_canvas.focus();
            } else {
                show_message('Prevented accidental addition of a very small region.');
            }
            return;
        }
    }

    function nc_reg_canvas_mouseover_handler(e) {
        // change the mouse cursor icon
        nc_redraw_reg_canvas();
        nc_reg_canvas.focus();
    }

    function nc_reg_canvas_mousemove_handler(e) {
        if (!nc_current_image_loaded) {
            return;
        }

        nc_current_x = e.offsetX;
        nc_current_y = e.offsetY;

        // display the cursor coordinates
        var rf = document.getElementById('region_info');
        if (rf != null && nc_is_region_info_visible) {
            var img_x = Math.round(nc_current_x * nc_canvas_scale);
            var img_y = Math.round(nc_current_y * nc_canvas_scale);
            rf.innerHTML = 'X:' + img_x + ',' + ' Y:' + img_y;
        }

        if (nc_is_region_selected) {
            // display the region's info if a region is selected
            if (rf != null && nc_is_region_info_visible && nc_user_sel_region_id !== -1) {
                var canvas_attr = nc_canvas_regions[nc_user_sel_region_id].attributes;
                switch (canvas_attr['name']) {
                    case NC_REGION_SHAPE.RECT:
                        break;

                    case NC_REGION_SHAPE.CIRCLE:
                        var rf = document.getElementById('region_info');
                        var attr = nc_canvas_regions[nc_user_sel_region_id].attributes;
                        rf.innerHTML += ',' + ' Radius:' + attr['r'];
                        break;

                    case NC_REGION_SHAPE.ELLIPSE:
                        var rf = document.getElementById('region_info');
                        var attr = nc_canvas_regions[nc_user_sel_region_id].attributes;
                        rf.innerHTML += ',' + ' X-radius:' + attr['rx'] + ',' + ' Y-radius:' + attr['ry'];
                        break;

                    case NC_REGION_SHAPE.POLYLINE:
                    case NC_REGION_SHAPE.POLYGON:
                        break;
                }
            }

            if (!nc_is_user_resizing_region) {
                // check if user moved mouse cursor to region boundary
                // which indicates an intention to resize the region
                nc_region_edge = is_on_region_corner(nc_current_x, nc_current_y);

                if (nc_region_edge[0] === nc_user_sel_region_id) {
                    switch (nc_region_edge[1]) {
                        // rect
                        case 1: // Fall-through // top-left corner of rect
                        case 3: // bottom-right corner of rect
                            nc_reg_canvas.style.cursor = "nwse-resize";
                            break;
                        case 2: // Fall-through // top-right corner of rect
                        case 4: // bottom-left corner of rect
                            nc_reg_canvas.style.cursor = "nesw-resize";
                            break;

                        case 5: // Fall-through // top-middle point of rect
                        case 7: // bottom-middle point of rect
                            nc_reg_canvas.style.cursor = "ns-resize";
                            break;
                        case 6: // Fall-through // top-middle point of rect
                        case 8: // bottom-middle point of rect
                            nc_reg_canvas.style.cursor = "ew-resize";
                            break;

                            // circle and ellipse
                        case 5:
                            nc_reg_canvas.style.cursor = "n-resize";
                            break;
                        case 6:
                            nc_reg_canvas.style.cursor = "e-resize";
                            break;

                        default:
                            nc_reg_canvas.style.cursor = "default";
                            break;
                    }

                    if (nc_region_edge[1] >= NC_POLYGON_RESIZE_VERTEX_OFFSET) {
                        // indicates mouse over polygon vertex
                        nc_reg_canvas.style.cursor = "crosshair";
                        show_message('To move vertex, simply drag the vertex. To add vertex, press [Ctrl] key and click on the edge. To delete vertex, press [Ctrl] key and click on vertex.');
                    }
                } else {
                    var yes = is_inside_this_region(nc_current_x,
                        nc_current_y,
                        nc_user_sel_region_id);
                    if (yes) {
                        nc_reg_canvas.style.cursor = "move";
                    } else {
                        nc_reg_canvas.style.cursor = "default";
                    }

                }
            }
        }

        if (nc_is_user_drawing_region) {
            // draw region as the user drags the mouse cursor
            if (nc_canvas_regions.length) {
                nc_redraw_reg_canvas(); // clear old intermediate rectangle
            } else {
                // first region being drawn, just clear the full region canvas
                nc_reg_ctx.clearRect(0, 0, nc_reg_canvas.width, nc_reg_canvas.height);
            }

            var region_x0 = nc_click_x0;
            var region_y0 = nc_click_y0;

            var dx = Math.round(Math.abs(nc_current_x - nc_click_x0));
            var dy = Math.round(Math.abs(nc_current_y - nc_click_y0));
            nc_reg_ctx.strokeStyle = nc_settings.ui.image.region_color; //  NC_THEME_BOUNDARY_FILL_COLOR;

            switch (nc_current_shape) {
                case NC_REGION_SHAPE.RECT:
                    if (nc_click_x0 < nc_current_x) {
                        if (nc_click_y0 < nc_current_y) {
                            region_x0 = nc_click_x0;
                            region_y0 = nc_click_y0;
                        } else {
                            region_x0 = nc_click_x0;
                            region_y0 = nc_current_y;
                        }
                    } else {
                        if (nc_click_y0 < nc_current_y) {
                            region_x0 = nc_current_x;
                            region_y0 = nc_click_y0;
                        } else {
                            region_x0 = nc_current_x;
                            region_y0 = nc_current_y;
                        }
                    }

                    nc_draw_rect_region(region_x0, region_y0, dx, dy, false);

                    // display the current region info
                    if (rf != null && nc_is_region_info_visible) {
                        rf.innerHTML += ',' + ' W:' + dx + ',' + ' H:' + dy;
                    }
                    break;

                case NC_REGION_SHAPE.CIRCLE:
                    var circle_radius = Math.round(Math.sqrt(dx * dx + dy * dy));
                    nc_draw_circle_region(region_x0, region_y0, circle_radius, false);

                    // display the current region info
                    if (rf != null && nc_is_region_info_visible) {
                        rf.innerHTML += ',' + ' Radius:' + circle_radius;
                    }
                    break;

                case NC_REGION_SHAPE.ELLIPSE:
                    nc_draw_ellipse_region(region_x0, region_y0, dx, dy, 0, false);

                    // display the current region info
                    if (rf != null && nc_is_region_info_visible) {
                        rf.innerHTML += ',' + ' X-radius:' + fixfloat(dx) + ',' + ' Y-radius:' + fixfloat(dy);
                    }
                    break;

                case NC_REGION_SHAPE.POLYLINE: // handled by polygon
                case NC_REGION_SHAPE.POLYGON:
                    // this is handled by the if ( nc_is_user_drawing_polygon ) { ... }
                    // see below
                    break;
            }
            nc_reg_canvas.focus();
        }

        if (nc_is_user_resizing_region) {
            // user has clicked mouse on bounding box edge and is now moving it
            // draw region as the user drags the mouse coursor
            if (nc_canvas_regions.length) {
                nc_redraw_reg_canvas(); // clear old intermediate rectangle
            } else {
                // first region being drawn, just clear the full region canvas
                nc_reg_ctx.clearRect(0, 0, nc_reg_canvas.width, nc_reg_canvas.height);
            }

            var region_id = nc_region_edge[0];
            var attr = nc_canvas_regions[region_id].attributes;
            switch (attr['name']) {
                case NC_REGION_SHAPE.RECT:
                    // original rectangle
                    var d = [attr['x'], attr['y'], 0, 0];
                    d[2] = d[0] + attr['width'];
                    d[3] = d[1] + attr['height'];

                    var mx = nc_current_x;
                    var my = nc_current_y;
                    var preserve_aspect_ratio = false;
                    // constrain (mx,my) to lie on a line connecting a diagonal of rectangle
                    if (nc_is_ctrl_pressed) {
                        preserve_aspect_ratio = true;
                    }

                    rect_update_corner(nc_region_edge[1], d, mx, my, preserve_aspect_ratio);
                    rect_standardize_coordinates(d);

                    var w = Math.abs(d[2] - d[0]);
                    var h = Math.abs(d[3] - d[1]);
                    nc_draw_rect_region(d[0], d[1], w, h, true);

                    if (rf != null && nc_is_region_info_visible) {
                        rf.innerHTML += ',' + ' W:' + w + ',' + ' H:' + h;
                    }
                    break;

                case NC_REGION_SHAPE.CIRCLE:
                    var dx = Math.abs(attr['cx'] - nc_current_x);
                    var dy = Math.abs(attr['cy'] - nc_current_y);
                    var new_r = Math.sqrt(dx * dx + dy * dy);
                    nc_draw_circle_region(attr['cx'],
                        attr['cy'],
                        new_r,
                        true);
                    if (rf != null && nc_is_region_info_visible) {
                        var curr_texts = rf.innerHTML.split(",");
                        rf.innerHTML = "";
                        rf.innerHTML += curr_texts[0] + ',' + curr_texts[1] + ',' + ' Radius:' + Math.round(new_r);
                    }
                    break;

                case NC_REGION_SHAPE.ELLIPSE:
                    var new_rx = attr['rx'];
                    var new_ry = attr['ry'];
                    var new_theta = attr['theta'];
                    var dx = Math.abs(attr['cx'] - nc_current_x);
                    var dy = Math.abs(attr['cy'] - nc_current_y);
                    switch (nc_region_edge[1]) {
                        case 5:
                            new_ry = Math.sqrt(dx * dx + dy * dy);
                            new_theta = Math.atan2(-(nc_current_x - attr['cx']), (nc_current_y - attr['cy']));
                            break;

                        case 6:
                            new_rx = Math.sqrt(dx * dx + dy * dy);
                            new_theta = Math.atan2((nc_current_y - attr['cy']), (nc_current_x - attr['cx']));
                            break;

                        default:
                            new_rx = dx;
                            new_ry = dy;
                            new_theta = 0;
                            break;
                    }

                    nc_draw_ellipse_region(attr['cx'],
                        attr['cy'],
                        new_rx,
                        new_ry,
                        new_theta,
                        true);
                    if (rf != null && nc_is_region_info_visible) {
                        var curr_texts = rf.innerHTML.split(",");
                        rf.innerHTML = "";
                        rf.innerHTML = curr_texts[0] + ',' + curr_texts[1] + ',' + ' X-radius:' + fixfloat(new_rx) + ',' + ' Y-radius:' + fixfloat(new_ry);
                    }
                    break;

                case NC_REGION_SHAPE.POLYLINE: // handled by polygon
                case NC_REGION_SHAPE.POLYGON:
                    var moved_all_points_x = attr['all_points_x'].slice(0);
                    var moved_all_points_y = attr['all_points_y'].slice(0);
                    var moved_vertex_id = nc_region_edge[1] - NC_POLYGON_RESIZE_VERTEX_OFFSET;

                    moved_all_points_x[moved_vertex_id] = nc_current_x;
                    moved_all_points_y[moved_vertex_id] = nc_current_y;

                    nc_draw_polygon_region(moved_all_points_x,
                        moved_all_points_y,
                        true,
                        attr['name']);
                    if (rf != null && nc_is_region_info_visible) {
                        rf.innerHTML += ',' + ' Vertices:' + attr['all_points_x'].length;
                    }
                    break;
            }
            nc_reg_canvas.focus();
        }

        if (nc_is_user_moving_region) {
            // draw region as the user drags the mouse coursor
            if (nc_canvas_regions.length) {
                nc_redraw_reg_canvas(); // clear old intermediate rectangle
            } else {
                // first region being drawn, just clear the full region canvas
                nc_reg_ctx.clearRect(0, 0, nc_reg_canvas.width, nc_reg_canvas.height);
            }

            var move_x = (nc_current_x - nc_region_click_x);
            var move_y = (nc_current_y - nc_region_click_y);
            var attr = nc_canvas_regions[nc_user_sel_region_id].attributes;

            switch (attr['name']) {
                case NC_REGION_SHAPE.RECT:
                    nc_draw_rect_region(attr['x'] + move_x,
                        attr['y'] + move_y,
                        attr['width'],
                        attr['height'],
                        true);
                    // display the current region info
                    if (rf != null && nc_is_region_info_visible) {
                        rf.innerHTML += ',' + ' W:' + attr['width'] + ',' + ' H:' + attr['height'];
                    }
                    break;

                case NC_REGION_SHAPE.CIRCLE:
                    nc_draw_circle_region(attr['cx'] + move_x,
                        attr['cy'] + move_y,
                        attr['r'],
                        true);
                    break;

                case NC_REGION_SHAPE.ELLIPSE:
                    attr['theta'] = get_default_value(attr['theta'], 0);
                    nc_draw_ellipse_region(attr['cx'] + move_x,
                        attr['cy'] + move_y,
                        attr['rx'],
                        attr['ry'],
                        attr['theta'],
                        true);
                    break;

                case NC_REGION_SHAPE.POLYLINE: // handled by polygon
                case NC_REGION_SHAPE.POLYGON:
                    var moved_all_points_x = attr['all_points_x'].slice(0);
                    var moved_all_points_y = attr['all_points_y'].slice(0);
                    for (var i = 0; i < moved_all_points_x.length; ++i) {
                        moved_all_points_x[i] += move_x;
                        moved_all_points_y[i] += move_y;
                    }
                    nc_draw_polygon_region(moved_all_points_x,
                        moved_all_points_y,
                        true,
                        attr['name']);
                    if (rf != null && nc_is_region_info_visible) {
                        rf.innerHTML += ',' + ' Vertices:' + attr['all_points_x'].length;
                    }
                    break;

                case NC_REGION_SHAPE.POINT:
                    nc_draw_point_region(attr['cx'] + move_x,
                        attr['cy'] + move_y,
                        true);
                    break;
            }
            nc_reg_canvas.focus();
            return;
        }

        if (nc_is_user_drawing_polygon) {
            nc_redraw_reg_canvas();
            var attr = nc_canvas_regions[nc_current_polygon_region_id].attributes;
            var all_points_x = attr['all_points_x'];
            var all_points_y = attr['all_points_y'];
            var npts = all_points_x.length;

            if (npts > 0) {
                var line_x = [all_points_x.slice(npts - 1), nc_current_x];
                var line_y = [all_points_y.slice(npts - 1), nc_current_y];
                nc_draw_polygon_region(line_x, line_y, false, attr['name']);
            }

            if (rf != null && nc_is_region_info_visible) {
                rf.innerHTML += ',' + ' Vertices:' + npts;
            }
        }
    }

    function nc_move_selected_regions(move_x, move_y) {
        var i, n;
        n = nc_region_selected_flag.length;
        for (i = 0; i < n; ++i) {
            if (nc_region_selected_flag[i]) {
                nc_move_region(i, move_x, move_y);
            }
        }
    }

    function nc_validate_move_region(x, y, canvas_attr) {
        switch (canvas_attr['name']) {
            case NC_REGION_SHAPE.RECT:
                // left and top boundary check
                if (x < 0 || y < 0) {
                    show_message('Region moved beyond image boundary. Resetting.');
                    return false;
                }
                // right and bottom boundary check
                if ((y + canvas_attr['height']) > nc_current_image_height ||
                    (x + canvas_attr['width']) > nc_current_image_width) {
                    show_message('Region moved beyond image boundary. Resetting.');
                    return false;
                }

                // same validation for all
            case NC_REGION_SHAPE.CIRCLE:
            case NC_REGION_SHAPE.ELLIPSE:
            case NC_REGION_SHAPE.POINT:
            case NC_REGION_SHAPE.POLYLINE:
            case NC_REGION_SHAPE.POLYGON:
                if (x < 0 || y < 0 ||
                    x > nc_current_image_width || y > nc_current_image_height) {
                    show_message('Region moved beyond image boundary. Resetting.');
                    return false;
                }
        }
        return true;
    }

    function nc_move_region(region_id, move_x, move_y) {
        var image_attr = nc_image_metadata[nc_image_id].regions[region_id].attributes;
        var canvas_attr = nc_canvas_regions[region_id].attributes;

        switch (canvas_attr['name']) {
            case NC_REGION_SHAPE.RECT:
                var xnew = image_attr['x'] + Math.round(move_x * nc_canvas_scale);
                var ynew = image_attr['y'] + Math.round(move_y * nc_canvas_scale);

                var is_valid = nc_validate_move_region(xnew, ynew, image_attr);
                if (!is_valid) { break; }

                image_attr['x'] = xnew;
                image_attr['y'] = ynew;

                canvas_attr['x'] = Math.round(image_attr['x'] / nc_canvas_scale);
                canvas_attr['y'] = Math.round(image_attr['y'] / nc_canvas_scale);
                break;

            case NC_REGION_SHAPE.CIRCLE: // Fall-through
            case NC_REGION_SHAPE.ELLIPSE: // Fall-through
            case NC_REGION_SHAPE.POINT:
                var cxnew = image_attr['cx'] + Math.round(move_x * nc_canvas_scale);
                var cynew = image_attr['cy'] + Math.round(move_y * nc_canvas_scale);

                var is_valid = nc_validate_move_region(cxnew, cynew, image_attr);
                if (!is_valid) { break; }

                image_attr['cx'] = cxnew;
                image_attr['cy'] = cynew;

                canvas_attr['cx'] = Math.round(image_attr['cx'] / nc_canvas_scale);
                canvas_attr['cy'] = Math.round(image_attr['cy'] / nc_canvas_scale);
                break;

            case NC_REGION_SHAPE.POLYLINE: // handled by polygon
            case NC_REGION_SHAPE.POLYGON:
                var img_px = image_attr['all_points_x'];
                var img_py = image_attr['all_points_y'];
                var canvas_px = canvas_attr['all_points_x'];
                var canvas_py = canvas_attr['all_points_y'];
                // clone for reverting if valiation fails
                var img_px_old = Object.assign({}, img_px);
                var img_py_old = Object.assign({}, img_py);

                // validate move
                for (var i = 0; i < img_px.length; ++i) {
                    var pxnew = img_px[i] + Math.round(move_x * nc_canvas_scale);
                    var pynew = img_py[i] + Math.round(move_y * nc_canvas_scale);
                    if (!nc_validate_move_region(pxnew, pynew, image_attr)) {
                        img_px = img_px_old;
                        img_py = img_py_old;
                        break;
                    }
                }
                // move points
                for (var i = 0; i < img_px.length; ++i) {
                    img_px[i] = img_px[i] + Math.round(move_x * nc_canvas_scale);
                    img_py[i] = img_py[i] + Math.round(move_y * nc_canvas_scale);
                }

                for (var i = 0; i < canvas_px.length; ++i) {
                    canvas_px[i] = Math.round(img_px[i] / nc_canvas_scale);
                    canvas_py[i] = Math.round(img_py[i] / nc_canvas_scale);
                }
                break;
        }
    }

    function nc_polygon_del_vertex(region_id, vertex_id) {
        var rs = nc_canvas_regions[region_id].attributes;
        var npts = rs['all_points_x'].length;
        var shape = rs['name'];
        if (shape !== NC_REGION_SHAPE.POLYGON && shape !== NC_REGION_SHAPE.POLYLINE) {
            show_message('Vertices can only be deleted from polygon/polyline.');
            return false;
        }
        if (npts <= 3 && shape === NC_REGION_SHAPE.POLYGON) {
            show_message('Failed to delete vertex because a polygon must have at least 3 vertices.');
            return false;
        }
        if (npts <= 2 && shape === NC_REGION_SHAPE.POLYLINE) {
            show_message('Failed to delete vertex because a polyline must have at least 2 vertices.');
            return false;
        }
        // delete vertex from canvas
        nc_canvas_regions[region_id].attributes['all_points_x'].splice(vertex_id, 1);
        nc_canvas_regions[region_id].attributes['all_points_y'].splice(vertex_id, 1);

        // delete vertex from image metadata
        nc_image_metadata[nc_image_id].regions[region_id].attributes['all_points_x'].splice(vertex_id, 1);
        nc_image_metadata[nc_image_id].regions[region_id].attributes['all_points_y'].splice(vertex_id, 1);
        return true;
    }

    // Canvas update routines
    function nc_redraw_reg_canvas() {
        if (nc_current_image_loaded) {
            nc_reg_ctx.clearRect(0, 0, nc_reg_canvas.width, nc_reg_canvas.height);
            if (nc_canvas_regions.length > 0) {
                if (nc_is_region_boundary_visible) {
                    draw_all_regions();
                }
                if (nc_is_region_id_visible) {
                    draw_all_region_id();
                }
            }
        }
    }

    function nc_clear_reg_canvas() {
        nc_reg_ctx.clearRect(0, 0, nc_reg_canvas.width, nc_reg_canvas.height);
    }

    function draw_all_regions() {
        var attr, is_selected, avalue;
        for (var i = 0; i < nc_canvas_regions.length; ++i) {
            attr = nc_canvas_regions[i].attributes;
            is_selected = nc_region_selected_flag[i];

            // region stroke style may depend on attribute value
            nc_reg_ctx.strokeStyle = nc_settings.ui.image.region_color; //NC_THEME_BOUNDARY_FILL_COLOR;

            switch (attr['name']) {
                case NC_REGION_SHAPE.RECT:
                    nc_draw_rect_region(attr['x'],
                        attr['y'],
                        attr['width'],
                        attr['height'],
                        is_selected);
                    break;

                case NC_REGION_SHAPE.CIRCLE:
                    nc_draw_circle_region(attr['cx'],
                        attr['cy'],
                        attr['r'],
                        is_selected);
                    break;

                case NC_REGION_SHAPE.ELLIPSE:
                    if (typeof(attr['theta']) === 'undefined') { attr['theta'] = 0; }
                    nc_draw_ellipse_region(attr['cx'],
                        attr['cy'],
                        attr['rx'],
                        attr['ry'],
                        attr['theta'],
                        is_selected);
                    break;

                case NC_REGION_SHAPE.POLYLINE: // handled by polygon
                case NC_REGION_SHAPE.POLYGON:
                    nc_draw_polygon_region(attr['all_points_x'],
                        attr['all_points_y'],
                        is_selected,
                        attr['name']);
                    break;

                case NC_REGION_SHAPE.POINT:
                    nc_draw_point_region(attr['cx'],
                        attr['cy'],
                        is_selected);
                    break;
            }
        }
    }

    // control point for resize of region boundaries
    function nc_draw_control_point(cx, cy) {
        nc_reg_ctx.beginPath();
        nc_reg_ctx.arc(cx, cy, NC_REGION_CONTROL_POINTS_RADIUS, 0, 2 * Math.PI, false);
        nc_reg_ctx.closePath();

        nc_reg_ctx.fillStyle = NC_THEME_CONTROL_POINT_COLOR;
        nc_reg_ctx.globalAlpha = 1.0;
        nc_reg_ctx.fill();
    }

    function nc_draw_rect_region(x, y, w, h, is_selected) {
        if (is_selected) {
            nc_draw_rect(x, y, w, h);

            nc_reg_ctx.strokeStyle = nc_settings.ui.image.region_color; //NC_THEME_SEL_REGION_FILL_BOUNDARY_COLOR;
            nc_reg_ctx.lineWidth = NC_THEME_REGION_BOUNDARY_WIDTH / 2;
            nc_reg_ctx.stroke();

            nc_reg_ctx.fillStyle = NC_THEME_SEL_REGION_FILL_COLOR;
            nc_reg_ctx.globalAlpha = NC_THEME_SEL_REGION_OPACITY;
            nc_reg_ctx.fill();
            nc_reg_ctx.globalAlpha = 1.0;

            nc_draw_control_point(x, y);
            nc_draw_control_point(x + w, y + h);
            nc_draw_control_point(x, y + h);
            nc_draw_control_point(x + w, y);
            nc_draw_control_point(x + w / 2, y);
            nc_draw_control_point(x + w / 2, y + h);
            nc_draw_control_point(x, y + h / 2);
            nc_draw_control_point(x + w, y + h / 2);
        } else {
            // draw a fill line
            nc_reg_ctx.lineWidth = NC_THEME_REGION_BOUNDARY_WIDTH / 2;
            nc_draw_rect(x, y, w, h);
            nc_reg_ctx.stroke();

            // xxxx3333
            // if (w > NC_THEME_REGION_BOUNDARY_WIDTH &&
            //     h > NC_THEME_REGION_BOUNDARY_WIDTH) {
            //     // draw a boundary line on both sides of the fill line
            //     nc_reg_ctx.strokeStyle = nc_settings.ui.image.region_color; //NC_THEME_BOUNDARY_LINE_COLOR;
            //     nc_reg_ctx.lineWidth = NC_THEME_REGION_BOUNDARY_WIDTH / 4;
            //     nc_draw_rect(x - NC_THEME_REGION_BOUNDARY_WIDTH / 2,
            //         y - NC_THEME_REGION_BOUNDARY_WIDTH / 2,
            //         w + NC_THEME_REGION_BOUNDARY_WIDTH,
            //         h + NC_THEME_REGION_BOUNDARY_WIDTH);
            //     nc_reg_ctx.stroke();

            //     nc_draw_rect(x + NC_THEME_REGION_BOUNDARY_WIDTH / 2,
            //         y + NC_THEME_REGION_BOUNDARY_WIDTH / 2,
            //         w - NC_THEME_REGION_BOUNDARY_WIDTH,
            //         h - NC_THEME_REGION_BOUNDARY_WIDTH);
            //     nc_reg_ctx.stroke();
            // }
        }
    }

    function nc_draw_rect(x, y, w, h) {
        nc_reg_ctx.beginPath();
        nc_reg_ctx.moveTo(x, y);
        nc_reg_ctx.lineTo(x + w, y);
        nc_reg_ctx.lineTo(x + w, y + h);
        nc_reg_ctx.lineTo(x, y + h);
        nc_reg_ctx.closePath();
    }

    function nc_draw_circle_region(cx, cy, r, is_selected) {
        if (is_selected) {
            nc_draw_circle(cx, cy, r);

            nc_reg_ctx.strokeStyle = nc_settings.ui.image.region_color; //NC_THEME_SEL_REGION_FILL_BOUNDARY_COLOR;
            nc_reg_ctx.lineWidth = NC_THEME_REGION_BOUNDARY_WIDTH / 2;
            nc_reg_ctx.stroke();

            nc_reg_ctx.fillStyle = NC_THEME_SEL_REGION_FILL_COLOR;
            nc_reg_ctx.globalAlpha = NC_THEME_SEL_REGION_OPACITY;
            nc_reg_ctx.fill();
            nc_reg_ctx.globalAlpha = 1.0;

            nc_draw_control_point(cx + r, cy);
        } else {
            // draw a fill line
            nc_reg_ctx.lineWidth = NC_THEME_REGION_BOUNDARY_WIDTH / 2;
            nc_draw_circle(cx, cy, r);
            nc_reg_ctx.stroke();
            // xxxx3333
            // if (r > NC_THEME_REGION_BOUNDARY_WIDTH) {
            //     // draw a boundary line on both sides of the fill line
            //     nc_reg_ctx.strokeStyle = nc_settings.ui.image.region_color; // NC_THEME_BOUNDARY_LINE_COLOR;
            //     nc_reg_ctx.lineWidth =  NC_THEME_REGION_BOUNDARY_WIDTH / 4;
            //     nc_draw_circle(cx, cy,
            //         r - NC_THEME_REGION_BOUNDARY_WIDTH / 2);
            //     nc_reg_ctx.stroke();
            //     nc_draw_circle(cx, cy,
            //         r + NC_THEME_REGION_BOUNDARY_WIDTH / 2);
            //     nc_reg_ctx.stroke();
            // }
        }
    }

    function nc_draw_circle(cx, cy, r) {
        nc_reg_ctx.beginPath();
        nc_reg_ctx.arc(cx, cy, r, 0, 2 * Math.PI, false);
        nc_reg_ctx.closePath();
    }

    function nc_draw_ellipse_region(cx, cy, rx, ry, rr, is_selected) {
        if (is_selected) {
            nc_draw_ellipse(cx, cy, rx, ry, rr);

            nc_reg_ctx.strokeStyle = nc_settings.ui.image.region_color; //NC_THEME_SEL_REGION_FILL_BOUNDARY_COLOR;
            nc_reg_ctx.lineWidth = NC_THEME_REGION_BOUNDARY_WIDTH / 2;
            nc_reg_ctx.stroke();

            nc_reg_ctx.fillStyle = NC_THEME_SEL_REGION_FILL_COLOR;
            nc_reg_ctx.globalAlpha = NC_THEME_SEL_REGION_OPACITY;
            nc_reg_ctx.fill();
            nc_reg_ctx.globalAlpha = 1.0;

            nc_draw_control_point(cx + rx * Math.cos(rr), cy + rx * Math.sin(rr));
            nc_draw_control_point(cx - rx * Math.cos(rr), cy - rx * Math.sin(rr));
            nc_draw_control_point(cx + ry * Math.sin(rr), cy - ry * Math.cos(rr));
            nc_draw_control_point(cx - ry * Math.sin(rr), cy + ry * Math.cos(rr));

        } else {
            // draw a fill line
            nc_reg_ctx.lineWidth = 1; // NC_THEME_REGION_BOUNDARY_WIDTH / 2;
            nc_draw_ellipse(cx, cy, rx, ry, rr);
            nc_reg_ctx.stroke();

            // xxxx3333
            // if (rx > NC_THEME_REGION_BOUNDARY_WIDTH &&
            //     ry > NC_THEME_REGION_BOUNDARY_WIDTH) {
            //     // draw a boundary line on both sides of the fill line
            //     nc_reg_ctx.strokeStyle = nc_settings.ui.image.region_color; //NC_THEME_BOUNDARY_LINE_COLOR;
            //     nc_reg_ctx.lineWidth = NC_THEME_REGION_BOUNDARY_WIDTH / 4;
            //     nc_draw_ellipse(cx, cy,
            //         rx + NC_THEME_REGION_BOUNDARY_WIDTH / 2,
            //         ry + NC_THEME_REGION_BOUNDARY_WIDTH / 2,
            //         rr);
            //     nc_reg_ctx.stroke();
            //     nc_draw_ellipse(cx, cy,
            //         rx - NC_THEME_REGION_BOUNDARY_WIDTH / 2,
            //         ry - NC_THEME_REGION_BOUNDARY_WIDTH / 2,
            //         rr);
            //     nc_reg_ctx.stroke();
            // }
        }
    }

    function nc_draw_ellipse(cx, cy, rx, ry, rr) {
        nc_reg_ctx.save();

        nc_reg_ctx.beginPath();
        nc_reg_ctx.ellipse(cx, cy, rx, ry, rr, 0, 2 * Math.PI);

        nc_reg_ctx.restore(); // restore to original state
        nc_reg_ctx.closePath();
    }

    function nc_draw_polygon_region(all_points_x, all_points_y, is_selected, shape) {
        if (is_selected) {
            nc_reg_ctx.strokeStyle = nc_settings.ui.image.region_color; //NC_THEME_SEL_REGION_FILL_BOUNDARY_COLOR;
            nc_reg_ctx.lineWidth = NC_THEME_REGION_BOUNDARY_WIDTH / 2;
            nc_reg_ctx.beginPath();
            nc_reg_ctx.moveTo(all_points_x[0], all_points_y[0]);
            for (var i = 1; i < all_points_x.length; ++i) {
                nc_reg_ctx.lineTo(all_points_x[i], all_points_y[i]);
            }
            if (shape === NC_REGION_SHAPE.POLYGON) {
                nc_reg_ctx.lineTo(all_points_x[0], all_points_y[0]); // close loop
            }
            nc_reg_ctx.stroke();

            nc_reg_ctx.fillStyle = NC_THEME_SEL_REGION_FILL_COLOR;
            nc_reg_ctx.globalAlpha = NC_THEME_SEL_REGION_OPACITY;
            nc_reg_ctx.fill();
            nc_reg_ctx.globalAlpha = 1.0;
            for (var i = 0; i < all_points_x.length; ++i) {
                nc_draw_control_point(all_points_x[i], all_points_y[i]);
            }
        } else {
            // draw a fill line
            nc_reg_ctx.lineWidth = 1; // NC_THEME_REGION_BOUNDARY_WIDTH / 2;
            nc_reg_ctx.beginPath();
            nc_reg_ctx.moveTo(all_points_x[0], all_points_y[0]);
            for (var i = 0; i < all_points_x.length; ++i) {
                nc_reg_ctx.lineTo(all_points_x[i], all_points_y[i]);
            }
            if (shape === NC_REGION_SHAPE.POLYGON) {
                nc_reg_ctx.lineTo(all_points_x[0], all_points_y[0]); // close loop
            }
            nc_reg_ctx.stroke();
        }
    }

    function nc_draw_point_region(cx, cy, is_selected) {
        if (is_selected) {
            nc_draw_point(cx, cy, NC_REGION_POINT_RADIUS);

            nc_reg_ctx.strokeStyle = nc_settings.ui.image.region_color; //NC_THEME_SEL_REGION_FILL_BOUNDARY_COLOR;
            nc_reg_ctx.lineWidth = NC_THEME_REGION_BOUNDARY_WIDTH / 2;
            nc_reg_ctx.stroke();

            nc_reg_ctx.fillStyle = NC_THEME_SEL_REGION_FILL_COLOR;
            nc_reg_ctx.globalAlpha = NC_THEME_SEL_REGION_OPACITY;
            nc_reg_ctx.fill();
            nc_reg_ctx.globalAlpha = 1.0;
        } else {
            // draw a fill line
            nc_reg_ctx.lineWidth = NC_THEME_REGION_BOUNDARY_WIDTH / 2;
            nc_draw_point(cx, cy, NC_REGION_POINT_RADIUS);
            nc_reg_ctx.stroke();

            // xxxx3333
            // draw a boundary line on both sides of the fill line
            // nc_reg_ctx.strokeStyle = nc_settings.ui.image.region_color; //NC_THEME_BOUNDARY_LINE_COLOR;
            // nc_reg_ctx.lineWidth = NC_THEME_REGION_BOUNDARY_WIDTH / 4;
            // nc_draw_point(cx, cy,
            //     NC_REGION_POINT_RADIUS - NC_THEME_REGION_BOUNDARY_WIDTH / 2);
            // nc_reg_ctx.stroke();
            // nc_draw_point(cx, cy,
            //     NC_REGION_POINT_RADIUS + NC_THEME_REGION_BOUNDARY_WIDTH / 2);
            // nc_reg_ctx.stroke();
        }
    }

    function nc_draw_point(cx, cy, r) {
        nc_reg_ctx.beginPath();
        nc_reg_ctx.arc(cx, cy, r, 0, 2 * Math.PI, false);
        nc_reg_ctx.closePath();
    }

    function draw_all_region_id() {
        nc_reg_ctx.shadowColor = "transparent";
        nc_reg_ctx.font = nc_settings.ui.image.region_label_font;
        for (var i = 0; i < nc_image_metadata[nc_image_id].regions.length; ++i) {
            var canvas_reg = nc_canvas_regions[i];

            var bbox = get_region_bounding_box(canvas_reg);
            var x = bbox[0];
            var y = bbox[1];
            var w = Math.abs(bbox[2] - bbox[0]);

            var char_width = nc_reg_ctx.measureText('M').width;
            var char_height = 1.8 * char_width;

            var annotation_str = (i + 1).toString();
            if (nc_settings.ui.image.region_label !== 'id') {
                annotation_str = nc_image_metadata[nc_image_id].regions[i].attributes['label'];
                if (typeof(annotation_str) === "undefined") { annotation_str = "bg"; }
            }

            var bgnd_rect_width;
            var strw = nc_reg_ctx.measureText(annotation_str).width;
            if (strw > w) {
                if (nc_settings.ui.image.region_label === 'id') {
                    // region-id is always visible in full
                    bgnd_rect_width = strw + char_width;
                } else {
                    // if text overflows, crop it
                    var str_max = Math.floor((w * annotation_str.length) / strw);
                    if (str_max > 1) {
                        annotation_str = annotation_str.substr(0, str_max - 1) + '.';
                        bgnd_rect_width = w;
                    } else {
                        annotation_str = annotation_str.substr(0, 1) + '.';
                        bgnd_rect_width = 2 * char_width;
                    }
                }
            } else {
                bgnd_rect_width = strw + char_width;
            }

            if (canvas_reg.attributes['name'] === NC_REGION_SHAPE.POLYGON ||
                canvas_reg.attributes['name'] === NC_REGION_SHAPE.POLYLINE) {
                // put label near the first vertex
                x = canvas_reg.attributes['all_points_x'][0];
                y = canvas_reg.attributes['all_points_y'][0];
            } else {
                // center the label
                x = x - (bgnd_rect_width / 2 - w / 2);
            }

            // ensure that the text is within the image boundaries
            if (y < char_height) {
                y = char_height;
            }

            // first, draw a background rectangle first
            nc_reg_ctx.fillStyle = 'black';
            nc_reg_ctx.globalAlpha = 0.8;
            nc_reg_ctx.fillRect(Math.floor(x),
                Math.floor(y - 1.1 * char_height),
                Math.floor(bgnd_rect_width),
                Math.floor(char_height));

            // then, draw text over this background rectangle
            nc_reg_ctx.globalAlpha = 1.0;
            nc_reg_ctx.fillStyle = 'yellow';
            nc_reg_ctx.fillText(annotation_str,
                Math.floor(x + 0.4 * char_width),
                Math.floor(y - 0.35 * char_height));

        }
    }

    function get_region_bounding_box(region) {
        var d = region.attributes;
        var bbox = new Array(4);

        switch (d['name']) {
            case 'rect':
                bbox[0] = d['x'];
                bbox[1] = d['y'];
                bbox[2] = d['x'] + d['width'];
                bbox[3] = d['y'] + d['height'];
                break;

            case 'circle':
                bbox[0] = d['cx'] - d['r'];
                bbox[1] = d['cy'] - d['r'];
                bbox[2] = d['cx'] + d['r'];
                bbox[3] = d['cy'] + d['r'];
                break;

            case 'ellipse':
                let radians = d['theta'];
                let radians90 = radians + Math.PI / 2;
                let ux = d['rx'] * Math.cos(radians);
                let uy = d['rx'] * Math.sin(radians);
                let vx = d['ry'] * Math.cos(radians90);
                let vy = d['ry'] * Math.sin(radians90);

                let width = Math.sqrt(ux * ux + vx * vx) * 2;
                let height = Math.sqrt(uy * uy + vy * vy) * 2;

                bbox[0] = d['cx'] - (width / 2);
                bbox[1] = d['cy'] - (height / 2);
                bbox[2] = d['cx'] + (width / 2);
                bbox[3] = d['cy'] + (height / 2);
                break;

            case 'polyline': // handled by polygon
            case 'polygon':
                var all_points_x = d['all_points_x'];
                var all_points_y = d['all_points_y'];

                var minx = Number.MAX_SAFE_INTEGER;
                var miny = Number.MAX_SAFE_INTEGER;
                var maxx = 0;
                var maxy = 0;
                for (var i = 0; i < all_points_x.length; ++i) {
                    if (all_points_x[i] < minx) {
                        minx = all_points_x[i];
                    }
                    if (all_points_x[i] > maxx) {
                        maxx = all_points_x[i];
                    }
                    if (all_points_y[i] < miny) {
                        miny = all_points_y[i];
                    }
                    if (all_points_y[i] > maxy) {
                        maxy = all_points_y[i];
                    }
                }
                bbox[0] = minx;
                bbox[1] = miny;
                bbox[2] = maxx;
                bbox[3] = maxy;
                break;

            case 'point':
                bbox[0] = d['cx'] - NC_REGION_POINT_RADIUS;
                bbox[1] = d['cy'] - NC_REGION_POINT_RADIUS;
                bbox[2] = d['cx'] + NC_REGION_POINT_RADIUS;
                bbox[3] = d['cy'] + NC_REGION_POINT_RADIUS;
                break;
        }
        return bbox;
    }

    // Region collision routines
    function is_inside_region(px, py, descending_order) {
        var N = nc_canvas_regions.length;
        if (N === 0) {
            return -1;
        }
        var start, end, del;
        // traverse the canvas regions in alternating ascending
        // and descending order to solve the issue of nested regions
        if (descending_order) {
            start = N - 1;
            end = -1;
            del = -1;
        } else {
            start = 0;
            end = N;
            del = 1;
        }

        var i = start;
        while (i !== end) {
            var yes = is_inside_this_region(px, py, i);
            if (yes) {
                return i;
            }
            i = i + del;
        }
        return -1;
    }

    function is_inside_this_region(px, py, region_id) {
        var attr = nc_canvas_regions[region_id].attributes;
        var result = false;
        switch (attr['name']) {
            case NC_REGION_SHAPE.RECT:
                result = is_inside_rect(attr['x'],
                    attr['y'],
                    attr['width'],
                    attr['height'],
                    px, py);
                break;

            case NC_REGION_SHAPE.CIRCLE:
                result = is_inside_circle(attr['cx'],
                    attr['cy'],
                    attr['r'],
                    px, py);
                break;

            case NC_REGION_SHAPE.ELLIPSE:
                result = is_inside_ellipse(attr['cx'],
                    attr['cy'],
                    attr['rx'],
                    attr['ry'],
                    attr['theta'],
                    px, py);
                break;

            case NC_REGION_SHAPE.POLYLINE: // handled by POLYGON
            case NC_REGION_SHAPE.POLYGON:
                result = is_inside_polygon(attr['all_points_x'],
                    attr['all_points_y'],
                    px, py);
                break;

            case NC_REGION_SHAPE.POINT:
                result = is_inside_point(attr['cx'],
                    attr['cy'],
                    px, py);
                break;
        }
        return result;
    }

    function is_inside_circle(cx, cy, r, px, py) {
        var dx = px - cx;
        var dy = py - cy;
        return (dx * dx + dy * dy) < r * r;
    }

    function is_inside_rect(x, y, w, h, px, py) {
        return px > x &&
            px < (x + w) &&
            py > y &&
            py < (y + h);
    }

    function is_inside_ellipse(cx, cy, rx, ry, rr, px, py) {
        // Inverse rotation of pixel coordinates
        var dx = Math.cos(-rr) * (cx - px) - Math.sin(-rr) * (cy - py)
        var dy = Math.sin(-rr) * (cx - px) + Math.cos(-rr) * (cy - py)

        return ((dx * dx) / (rx * rx)) + ((dy * dy) / (ry * ry)) < 1;
    }

    // returns 0 when (px,py) is outside the polygon
    // source: http://geomalgorithms.com/a03-_inclusion.html
    function is_inside_polygon(all_points_x, all_points_y, px, py) {
        if (all_points_x.length === 0 || all_points_y.length === 0) {
            return 0;
        }

        var wn = 0; // the  winding number counter
        var n = all_points_x.length;
        var i;
        // loop through all edges of the polygon
        for (i = 0; i < n - 1; ++i) { // edge from V[i] to  V[i+1]
            var is_left_value = is_left(all_points_x[i], all_points_y[i],
                all_points_x[i + 1], all_points_y[i + 1],
                px, py);

            if (all_points_y[i] <= py) {
                if (all_points_y[i + 1] > py && is_left_value > 0) {
                    ++wn;
                }
            } else {
                if (all_points_y[i + 1] <= py && is_left_value < 0) {
                    --wn;
                }
            }
        }

        // also take into account the loop closing edge that connects last point with first point
        var is_left_value = is_left(all_points_x[n - 1], all_points_y[n - 1],
            all_points_x[0], all_points_y[0],
            px, py);

        if (all_points_y[n - 1] <= py) {
            if (all_points_y[0] > py && is_left_value > 0) {
                ++wn;
            }
        } else {
            if (all_points_y[0] <= py && is_left_value < 0) {
                --wn;
            }
        }

        if (wn === 0) {
            return 0;
        } else {
            return 1;
        }
    }

    function is_inside_point(cx, cy, px, py) {
        var dx = px - cx;
        var dy = py - cy;
        var r2 = NC_POLYGON_VERTEX_MATCH_TOL * NC_POLYGON_VERTEX_MATCH_TOL;
        return (dx * dx + dy * dy) < r2;
    }

    // returns
    // >0 if (x2,y2) lies on the left side of line joining (x0,y0) and (x1,y1)
    // =0 if (x2,y2) lies on the line joining (x0,y0) and (x1,y1)
    // >0 if (x2,y2) lies on the right side of line joining (x0,y0) and (x1,y1)
    // source: http://geomalgorithms.com/a03-_inclusion.html
    function is_left(x0, y0, x1, y1, x2, y2) {
        return (((x1 - x0) * (y2 - y0)) - ((x2 - x0) * (y1 - y0)));
    }

    function is_on_region_corner(px, py) {
        var nc_region_edge = [-1, -1]; // region_id, corner_id [top-left=1,top-right=2,bottom-right=3,bottom-left=4]

        for (var i = 0; i < nc_canvas_regions.length; ++i) {
            var attr = nc_canvas_regions[i].attributes;
            var result = false;
            nc_region_edge[0] = i;

            switch (attr['name']) {
                case NC_REGION_SHAPE.RECT:
                    result = is_on_rect_edge(attr['x'],
                        attr['y'],
                        attr['width'],
                        attr['height'],
                        px, py);
                    break;

                case NC_REGION_SHAPE.CIRCLE:
                    result = is_on_circle_edge(attr['cx'],
                        attr['cy'],
                        attr['r'],
                        px, py);
                    break;

                case NC_REGION_SHAPE.ELLIPSE:
                    result = is_on_ellipse_edge(attr['cx'],
                        attr['cy'],
                        attr['rx'],
                        attr['ry'],
                        attr['theta'],
                        px, py);
                    break;

                case NC_REGION_SHAPE.POLYLINE: // handled by polygon
                case NC_REGION_SHAPE.POLYGON:
                    result = is_on_polygon_vertex(attr['all_points_x'],
                        attr['all_points_y'],
                        px, py);
                    if (result === 0) {
                        result = is_on_polygon_edge(attr['all_points_x'],
                            attr['all_points_y'],
                            px, py);
                    }
                    break;

                case NC_REGION_SHAPE.POINT:
                    // since there are no edges of a point
                    result = 0;
                    break;
            }

            if (result > 0) {
                nc_region_edge[1] = result;
                return nc_region_edge;
            }
        }
        nc_region_edge[0] = -1;
        return nc_region_edge;
    }

    function is_on_rect_edge(x, y, w, h, px, py) {
        var dx0 = Math.abs(x - px);
        var dy0 = Math.abs(y - py);
        var dx1 = Math.abs(x + w - px);
        var dy1 = Math.abs(y + h - py);
        //[top-left=1,top-right=2,bottom-right=3,bottom-left=4]
        if (dx0 < NC_REGION_EDGE_TOL &&
            dy0 < NC_REGION_EDGE_TOL) {
            return 1;
        }
        if (dx1 < NC_REGION_EDGE_TOL &&
            dy0 < NC_REGION_EDGE_TOL) {
            return 2;
        }
        if (dx1 < NC_REGION_EDGE_TOL &&
            dy1 < NC_REGION_EDGE_TOL) {
            return 3;
        }

        if (dx0 < NC_REGION_EDGE_TOL &&
            dy1 < NC_REGION_EDGE_TOL) {
            return 4;
        }

        var mx0 = Math.abs(x + w / 2 - px);
        var my0 = Math.abs(y + h / 2 - py);
        //[top-middle=5,right-middle=6,bottom-middle=7,left-middle=8]
        if (mx0 < NC_REGION_EDGE_TOL &&
            dy0 < NC_REGION_EDGE_TOL) {
            return 5;
        }
        if (dx1 < NC_REGION_EDGE_TOL &&
            my0 < NC_REGION_EDGE_TOL) {
            return 6;
        }
        if (mx0 < NC_REGION_EDGE_TOL &&
            dy1 < NC_REGION_EDGE_TOL) {
            return 7;
        }
        if (dx0 < NC_REGION_EDGE_TOL &&
            my0 < NC_REGION_EDGE_TOL) {
            return 8;
        }

        return 0;
    }

    function is_on_circle_edge(cx, cy, r, px, py) {
        var dx = cx - px;
        var dy = cy - py;
        if (Math.abs(Math.sqrt(dx * dx + dy * dy) - r) < NC_REGION_EDGE_TOL) {
            var theta = Math.atan2(py - cy, px - cx);
            if (Math.abs(theta - (Math.PI / 2)) < NC_THETA_TOL ||
                Math.abs(theta + (Math.PI / 2)) < NC_THETA_TOL) {
                return 5;
            }
            if (Math.abs(theta) < NC_THETA_TOL ||
                Math.abs(Math.abs(theta) - Math.PI) < NC_THETA_TOL) {
                return 6;
            }

            if (theta > 0 && theta < (Math.PI / 2)) {
                return 1;
            }
            if (theta > (Math.PI / 2) && theta < (Math.PI)) {
                return 4;
            }
            if (theta < 0 && theta > -(Math.PI / 2)) {
                return 2;
            }
            if (theta < -(Math.PI / 2) && theta > -Math.PI) {
                return 3;
            }
        } else {
            return 0;
        }
    }

    function is_on_ellipse_edge(cx, cy, rx, ry, rr, px, py) {
        // Inverse rotation of pixel coordinates
        px = px - cx;
        py = py - cy;
        var px_ = Math.cos(-rr) * px - Math.sin(-rr) * py;
        var py_ = Math.sin(-rr) * px + Math.cos(-rr) * py;
        px = px_ + cx;
        py = py_ + cy;

        var dx = (cx - px) / rx;
        var dy = (cy - py) / ry;

        if (Math.abs(Math.sqrt(dx * dx + dy * dy) - 1) < NC_ELLIPSE_EDGE_TOL) {
            var theta = Math.atan2(py - cy, px - cx);
            if (Math.abs(theta - (Math.PI / 2)) < NC_THETA_TOL ||
                Math.abs(theta + (Math.PI / 2)) < NC_THETA_TOL) {
                return 5;
            }
            if (Math.abs(theta) < NC_THETA_TOL ||
                Math.abs(Math.abs(theta) - Math.PI) < NC_THETA_TOL) {
                return 6;
            }
        } else {
            return 0;
        }
    }

    function is_on_polygon_vertex(all_points_x, all_points_y, px, py) {
        var i, n;
        n = all_points_x.length;

        for (i = 0; i < n; ++i) {
            if (Math.abs(all_points_x[i] - px) < NC_POLYGON_VERTEX_MATCH_TOL &&
                Math.abs(all_points_y[i] - py) < NC_POLYGON_VERTEX_MATCH_TOL) {
                return (NC_POLYGON_RESIZE_VERTEX_OFFSET + i);
            }
        }
        return 0;
    }

    function is_on_polygon_edge(all_points_x, all_points_y, px, py) {
        var i, n, di, d;
        n = all_points_x.length;
        d = [];
        for (i = 0; i < n - 1; ++i) {
            di = dist_to_line(px, py, all_points_x[i], all_points_y[i], all_points_x[i + 1], all_points_y[i + 1]);
            d.push(di);
        }
        // closing edge
        di = dist_to_line(px, py, all_points_x[n - 1], all_points_y[n - 1], all_points_x[0], all_points_y[0]);
        d.push(di);

        var smallest_value = d[0];
        var smallest_index = 0;
        n = d.length;
        for (i = 1; i < n; ++i) {
            if (d[i] < smallest_value) {
                smallest_value = d[i];
                smallest_index = i;
            }
        }
        if (smallest_value < NC_POLYGON_VERTEX_MATCH_TOL) {
            return (NC_POLYGON_RESIZE_VERTEX_OFFSET + smallest_index);
        } else {
            return 0;
        }
    }

    function is_point_inside_bounding_box(x, y, x1, y1, x2, y2) {
        // ensure that (x1,y1) is top left and (x2,y2) is bottom right corner of rectangle
        var rect = {};
        if (x1 < x2) {
            rect.x1 = x1;
            rect.x2 = x2;
        } else {
            rect.x1 = x2;
            rect.x2 = x1;
        }
        if (y1 < y2) {
            rect.y1 = y1;
            rect.y2 = y2;
        } else {
            rect.y1 = y2;
            rect.y2 = y1;
        }

        if (x >= rect.x1 && x <= rect.x2 && y >= rect.y1 && y <= rect.y2) {
            return true;
        } else {
            return false;
        }
    }

    function dist_to_line(x, y, x1, y1, x2, y2) {
        if (is_point_inside_bounding_box(x, y, x1, y1, x2, y2)) {
            var dy = y2 - y1;
            var dx = x2 - x1;
            var nr = Math.abs(dy * x - dx * y + x2 * y1 - y2 * x1);
            var dr = Math.sqrt(dx * dx + dy * dy);
            var dist = nr / dr;
            return Math.round(dist);
        } else {
            return Number.MAX_SAFE_INTEGER;
        }
    }

    function rect_standardize_coordinates(d) {
        // d[x0,y0,x1,y1]
        // ensures that (d[0],d[1]) is top-left corner while
        // (d[2],d[3]) is bottom-right corner
        if (d[0] > d[2]) {
            // swap
            var t = d[0];
            d[0] = d[2];
            d[2] = t;
        }

        if (d[1] > d[3]) {
            // swap
            var t = d[1];
            d[1] = d[3];
            d[3] = t;
        }
    }

    function rect_update_corner(corner_id, d, x, y, preserve_aspect_ratio) {
        // pre-condition : d[x0,y0,x1,y1] is standardized
        // post-condition : corner is moved ( d may not stay standardized )
        if (preserve_aspect_ratio) {
            switch (corner_id) {
                case 1: // Fall-through // top-left
                case 3: // bottom-right
                    var dx = d[2] - d[0];
                    var dy = d[3] - d[1];
                    var norm = Math.sqrt(dx * dx + dy * dy);
                    var nx = dx / norm; // x component of unit vector along the diagonal of rect
                    var ny = dy / norm; // y component
                    var proj = (x - d[0]) * nx + (y - d[1]) * ny;
                    var proj_x = nx * proj;
                    var proj_y = ny * proj;
                    // constrain (mx,my) to lie on a line connecting (x0,y0) and (x1,y1)
                    x = Math.round(d[0] + proj_x);
                    y = Math.round(d[1] + proj_y);
                    break;

                case 2: // Fall-through // top-right
                case 4: // bottom-left
                    var dx = d[2] - d[0];
                    var dy = d[1] - d[3];
                    var norm = Math.sqrt(dx * dx + dy * dy);
                    var nx = dx / norm; // x component of unit vector along the diagonal of rect
                    var ny = dy / norm; // y component
                    var proj = (x - d[0]) * nx + (y - d[3]) * ny;
                    var proj_x = nx * proj;
                    var proj_y = ny * proj;
                    // constrain (mx,my) to lie on a line connecting (x0,y0) and (x1,y1)
                    x = Math.round(d[0] + proj_x);
                    y = Math.round(d[3] + proj_y);
                    break;
            }
        }

        switch (corner_id) {
            case 1: // top-left
                d[0] = x;
                d[1] = y;
                break;

            case 3: // bottom-right
                d[2] = x;
                d[3] = y;
                break;

            case 2: // top-right
                d[2] = x;
                d[1] = y;
                break;

            case 4: // bottom-left
                d[0] = x;
                d[3] = y;
                break;

            case 5: // top-middle
                d[1] = y;
                break;

            case 6: // right-middle
                d[2] = x;
                break;

            case 7: // bottom-middle
                d[3] = y;
                break;

            case 8: // left-middle
                d[0] = x;
                break;
        }
    }

    function nc_refresh() {
        if (!nc_current_image_loaded) {
            return;
        }

        show_message('Updating user interface components.');
        switch (nc_display_area_content_name) {
            case NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID:
                image_grid_set_content_panel_height_fixed();
                image_grid_set_content_to_current_group();
                break;
            case NC_DISPLAY_AREA_CONTENT_NAME.IMAGE:
                if (!nc_is_window_resized && nc_current_image_loaded) {
                    nc_is_window_resized = true;
                    nc_show_image(nc_image_index);

                    if (nc_is_canvas_zoomed) {
                        reset_zoom();
                    }
                }
                break;
        }
    }

    // Shortcut key handlers
    function nc_window_keydown_handler(e) {
        if (e.target === document.body) {
            // process the keyboard event
            nc_handle_global_keydown_event(e);
        }
    }

    // global keys are active irrespective of element focus
    // arrow keys, n, p, s, o, space, d, Home, End, PageUp, PageDown
    function nc_handle_global_keydown_event(e) {
        // zoom
        if (nc_current_image_loaded) {
            if (e.key === "+") {
                zoom_in();
                return;
            }

            if (e.key === "=") {
                reset_zoom();
                return;
            }

            if (e.key === "-") {
                zoom_out();
                return;
            }
        }

        if (e.key === 'ArrowRight' || e.key === 'n') {
            move_to_next_image();
            e.preventDefault();
            return;
        }
        if (e.key === 'ArrowLeft' || e.key === 'p') {
            move_to_prev_image();
            e.preventDefault();
            return;
        }

        if (e.key === 'Home') {
            show_first_image();
            e.preventDefault();
            return;
        }
        if (e.key === 'End') {
            show_last_image();
            e.preventDefault();
            return;
        }
        if (e.key === 'PageDown') {
            jump_to_next_image_block();
            e.preventDefault();
            return;
        }
        if (e.key === 'PageUp') {
            jump_to_prev_image_block();
            e.preventDefault();
            return;
        }

        if (e.key === 'a') {
            if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
                // select all in image grid
                image_grid_group_toggle_select_all();
            }
        }

        if (e.key === 'Escape') {
            e.preventDefault();
            if (nc_is_loading_current_image) {
                nc_cancel_current_image_loading();
            }

            if (nc_is_user_resizing_region) {
                // cancel region resizing action
                nc_is_user_resizing_region = false;
            }

            if (nc_is_region_selected) {
                // clear all region selections
                nc_is_region_selected = false;
                nc_user_sel_region_id = -1;
                toggle_all_regions_selection(false);
            }

            if (nc_is_user_drawing_polygon) {
                nc_is_user_drawing_polygon = false;
                nc_canvas_regions.splice(nc_current_polygon_region_id, 1); // delete
            }

            if (nc_is_user_drawing_region) {
                nc_is_user_drawing_region = false;
            }

            if (nc_is_user_resizing_region) {
                nc_is_user_resizing_region = false
            }

            if (nc_is_user_moving_region) {
                nc_is_user_moving_region = false
            }

            nc_redraw_reg_canvas();
            return;
        }

        if (e.key === 'F1') { // F1 for help
            set_display_area_content(NC_DISPLAY_AREA_CONTENT_NAME.PAGE_GETTING_STARTED);
            e.preventDefault();
            return;
        }
        if (e.key === 'F2') { // F2 for about
            set_display_area_content(NC_DISPLAY_AREA_CONTENT_NAME.PAGE_ABOUT);
            e.preventDefault();
            return;
        }
    }

    function nc_reg_canvas_keyup_handler(e) {
        if (e.key === 'Control') {
            nc_is_ctrl_pressed = false;
        }
    }

    function nc_reg_canvas_keydown_handler(e) {
        if (e.key === 'Control') {
            nc_is_ctrl_pressed = true;
        }

        if (nc_current_image_loaded) {
            if (e.key === 'Enter') {
                if (nc_current_shape === NC_REGION_SHAPE.POLYLINE ||
                    nc_current_shape === NC_REGION_SHAPE.POLYGON) {
                    nc_polyshape_finish_drawing(); // maybe add new region, xxxx1111
                }
            }
            if (e.key === 'Backspace') {
                if (nc_current_shape === NC_REGION_SHAPE.POLYLINE ||
                    nc_current_shape === NC_REGION_SHAPE.POLYGON) {
                    nc_polyshape_delete_last_vertex();
                }
            }

            if (e.key === 'a') {
                select_all_regions();
                e.preventDefault();
                return;
            }

            if (e.key === 'c') {
                if (nc_is_region_selected ||
                    nc_is_all_region_selected) {
                    copy_selected_regions();
                }
                e.preventDefault();
                return;
            }

            if (e.key === 'v') {
                paste_selected_regions();
                e.preventDefault();
                return;
            }

            if (e.key === 'b') {
                toggle_boundary_visibility();
                e.preventDefault();
                return;
            }

            if (e.key === 'l') {
                toggle_region_id_visibility();
                e.preventDefault();
                return;
            }

            if (e.key === 'd') {
                if (nc_is_region_selected ||
                    nc_is_all_region_selected) {
                    delete_selected_regions();
                }
                e.preventDefault();
                return;
            }

            if (nc_is_region_selected) {
                if (e.key === 'ArrowRight' ||
                    e.key === 'ArrowLeft' ||
                    e.key === 'ArrowDown' ||
                    e.key === 'ArrowUp') {
                    var del = 1;
                    if (e.shiftKey) {
                        del = 10;
                    }
                    var move_x = 0;
                    var move_y = 0;
                    switch (e.key) {
                        case 'ArrowLeft':
                            move_x = -del;
                            break;
                        case 'ArrowUp':
                            move_y = -del;
                            break;
                        case 'ArrowRight':
                            move_x = del;
                            break;
                        case 'ArrowDown':
                            move_y = del;
                            break;
                    }
                    nc_move_selected_regions(move_x, move_y);
                    nc_redraw_reg_canvas();
                    e.preventDefault();
                    return;
                }
            }
        }
        nc_handle_global_keydown_event(e);
    }

    function nc_polyshape_finish_drawing() {
        if (nc_is_user_drawing_polygon) {
            // double click is used to indicate completion of
            // polygon or polyline drawing action
            var new_region_id = nc_current_polygon_region_id;
            var new_region_shape = nc_current_shape;

            var npts = nc_canvas_regions[new_region_id].attributes['all_points_x'].length;
            if (npts <= 2 && new_region_shape === NC_REGION_SHAPE.POLYGON) {
                show_message('For a polygon, you must define at least 3 points. Press [Esc] to cancel drawing operation.!');
                return;
            }
            if (npts <= 1 && new_region_shape === NC_REGION_SHAPE.POLYLINE) {
                show_message('A polyline must have at least 2 points. Press [Esc] to cancel drawing operation.!');
                return;
            }

            var img_id = nc_image_id;
            nc_current_polygon_region_id = -1;
            nc_is_user_drawing_polygon = false;
            nc_is_user_drawing_region = false;

            nc_image_metadata[img_id].regions[new_region_id] = {}; // create placeholder
            nc_polyshape_add_new_polyshape(img_id, new_region_shape, new_region_id);
            select_only_region(new_region_id); // select new region

            nc_redraw_reg_canvas();
            nc_reg_canvas.focus();
        }
        return;
    }

    function nc_polyshape_delete_last_vertex() {
        if (nc_is_user_drawing_polygon) {
            var npts = nc_canvas_regions[nc_current_polygon_region_id].attributes['all_points_x'].length;
            if (npts > 0) {
                // delete 
                nc_canvas_regions[nc_current_polygon_region_id].attributes['all_points_x'].splice(npts - 1, 1);
                nc_canvas_regions[nc_current_polygon_region_id].attributes['all_points_y'].splice(npts - 1, 1);

                nc_redraw_reg_canvas();
                nc_reg_canvas.focus();
            }
        }
    }

    function nc_polyshape_add_new_polyshape(img_id, region_shape, region_id) {
        // add all polygon points stored in nc_canvas_regions[]
        var all_points_x = nc_canvas_regions[region_id].attributes['all_points_x'].slice(0);
        var all_points_y = nc_canvas_regions[region_id].attributes['all_points_y'].slice(0);

        var canvas_all_points_x = [];
        var canvas_all_points_y = [];
        var n = all_points_x.length;
        var i;
        for (i = 0; i < n; ++i) {
            all_points_x[i] = Math.round(all_points_x[i] * nc_canvas_scale);
            all_points_y[i] = Math.round(all_points_y[i] * nc_canvas_scale);

            canvas_all_points_x[i] = Math.round(all_points_x[i] / nc_canvas_scale);
            canvas_all_points_y[i] = Math.round(all_points_y[i] / nc_canvas_scale);
        }

        var polygon_region = new file_region();
        polygon_region.attributes['name'] = region_shape;
        polygon_region.attributes['all_points_x'] = all_points_x;
        polygon_region.attributes['all_points_y'] = all_points_y;
        nc_image_metadata[img_id].regions[region_id] = polygon_region;

        // update canvas
        if (img_id === nc_image_id) {
            nc_canvas_regions[region_id].attributes['name'] = region_shape;
            nc_canvas_regions[region_id].attributes['all_points_x'] = canvas_all_points_x;
            nc_canvas_regions[region_id].attributes['all_points_y'] = canvas_all_points_y;
        }
    }

    function delete_selected_regions() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            return;
        }

        if (!nc_current_image_loaded) {
            show_message('First load some images!');
            return;
        }

        var del_region_count = 0;
        if (nc_is_all_region_selected) {
            del_region_count = nc_canvas_regions.length;
            nc_canvas_regions.splice(0); // delete region 0
            nc_image_metadata[nc_image_id].regions.splice(0);
        } else {
            var sorted_sel_reg_id = [];
            for (var i = 0; i < nc_canvas_regions.length; ++i) {
                if (nc_region_selected_flag[i]) {
                    sorted_sel_reg_id.push(i);
                    nc_region_selected_flag[i] = false;
                }
            }
            sorted_sel_reg_id.sort(function(a, b) {
                return (b - a);
            });
            for (var i = 0; i < sorted_sel_reg_id.length; ++i) {
                nc_canvas_regions.splice(sorted_sel_reg_id[i], 1);
                nc_image_metadata[nc_image_id].regions.splice(sorted_sel_reg_id[i], 1);
                del_region_count += 1;
            }

            if (sorted_sel_reg_id.length) {
                nc_reg_canvas.style.cursor = "default";
            }
        }

        nc_is_all_region_selected = false;
        nc_is_region_selected = false;
        nc_user_sel_region_id = -1;

        if (del_region_count > 0) {
            annotation_editor_hide();
        }

        if (nc_canvas_regions.length === 0) {
            // all regions were deleted, hence clear region canvas
            nc_clear_reg_canvas();
        } else {
            nc_redraw_reg_canvas();
        }
        nc_reg_canvas.focus();

        show_message('Deleted ' + del_region_count + ' selected regions');
    }

    function select_all_regions() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            image_grid_group_toggle_select_all();
            return;
        }

        if (!nc_current_image_loaded) {
            show_message('First load some images!');
            return;
        }

        toggle_all_regions_selection(true);
        nc_is_all_region_selected = true;
        nc_redraw_reg_canvas();
    }

    function copy_selected_regions() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            return;
        }

        if (!nc_current_image_loaded) {
            show_message('First load some images!');
            return;
        }

        if (nc_is_region_selected ||
            nc_is_all_region_selected) {
            nc_copied_image_regions.splice(0);
            for (var i = 0; i < nc_image_metadata[nc_image_id].regions.length; ++i) {
                var img_region = nc_image_metadata[nc_image_id].regions[i];
                var canvas_region = nc_canvas_regions[i];
                if (nc_region_selected_flag[i]) {
                    nc_copied_image_regions.push(clone_image_region(img_region));
                }
            }
            show_message('Copied ' + nc_copied_image_regions.length +
                ' selected regions. Press Ctrl + v to paste');
        } else {
            show_message('Select a region first!');
        }
    }

    function paste_selected_regions() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            return;
        }

        if (!nc_current_image_loaded) {
            show_message('First load some images!');
            return;
        }

        if (nc_copied_image_regions.length) {
            var pasted_reg_count = 0;
            for (var i = 0; i < nc_copied_image_regions.length; ++i) {
                // ensure copied the regions are within this image's boundaries
                var bbox = get_region_bounding_box(nc_copied_image_regions[i]);
                if (bbox[2] < nc_current_image_width &&
                    bbox[3] < nc_current_image_height) {
                    var r = clone_image_region(nc_copied_image_regions[i]);
                    nc_image_metadata[nc_image_id].regions.push(r);

                    pasted_reg_count += 1;
                }
            }
            nc_load_canvas_regions();
            var discarded_reg_count = nc_copied_image_regions.length - pasted_reg_count;
            show_message('Pasted ' + pasted_reg_count + ' regions. ' +
                'Discarded ' + discarded_reg_count + ' regions exceeding image boundary.');
            nc_redraw_reg_canvas();
            nc_reg_canvas.focus();
        } else {
            show_message('To paste a region, you first need to select a region and copy it!');
        }
    }

    function show_first_image() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            if (nc_image_grid_group_var.length) {
                image_grid_group_prev({ 'value': 0 }); // simulate button click
            } else {
                show_message('First, create groups by selecting items from "Group by" dropdown list');
            }
            return;
        }

        if (nc_image_count > 0) {
            nc_show_image(nc_img_fn_list_img_index_list[0]);
        }
    }

    function show_last_image() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            if (nc_image_grid_group_var.length) {
                image_grid_group_prev({ 'value': nc_image_grid_group_var.length - 1 }); // simulate button click
            } else {
                show_message('First, create groups by selecting items from "Group by" dropdown list');
            }
            return;
        }

        if (nc_image_count > 0) {
            var last_img_index = nc_img_fn_list_img_index_list.length - 1;
            nc_show_image(nc_img_fn_list_img_index_list[last_img_index]);
        }
    }

    function jump_image_block_get_count() {
        var n = nc_img_fn_list_img_index_list.length;
        if (n < 20) {
            return 2;
        }
        if (n < 100) {
            return 10;
        }
        if (n < 1000) {
            return 25;
        }
        if (n < 5000) {
            return 50;
        }
        if (n < 10000) {
            return 100;
        }
        if (n < 50000) {
            return 500;
        }

        return Math.round(n / 50);
    }

    function jump_to_next_image_block() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            return;
        }

        var jump_count = jump_image_block_get_count();
        if (jump_count > 1) {
            var current_img_index = nc_image_index;
            if (nc_img_fn_list_img_index_list.includes(current_img_index)) {
                var list_index = nc_img_fn_list_img_index_list.indexOf(current_img_index);
                var next_list_index = list_index + jump_count;
                if ((next_list_index + 1) > nc_img_fn_list_img_index_list.length) {
                    next_list_index = 0;
                }
                var next_img_index = nc_img_fn_list_img_index_list[next_list_index];
                nc_show_image(next_img_index);
            }
        } else {
            move_to_next_image();
        }
    }

    function jump_to_prev_image_block() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            return;
        }

        var jump_count = jump_image_block_get_count();
        if (jump_count > 1) {
            var current_img_index = nc_image_index;
            if (nc_img_fn_list_img_index_list.includes(current_img_index)) {
                var list_index = nc_img_fn_list_img_index_list.indexOf(current_img_index);
                var prev_list_index = list_index - jump_count;
                if (prev_list_index < 0) {
                    prev_list_index = nc_img_fn_list_img_index_list.length - 1;
                }
                var prev_img_index = nc_img_fn_list_img_index_list[prev_list_index];
                nc_show_image(prev_img_index);
            }
        } else {
            move_to_prev_image();
        }
    }

    function move_to_prev_image() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            if (nc_image_grid_group_var.length) {
                var last_group_index = nc_image_grid_group_var.length - 1;
                image_grid_group_prev({ 'value': last_group_index }); // simulate button click
            } else {
                show_message('First, create groups by selecting items from "Group by" dropdown list');
            }
            return;
        }

        if (nc_image_count > 0) {
            var current_img_index = nc_image_index;
            if (nc_img_fn_list_img_index_list.includes(current_img_index)) {
                var list_index = nc_img_fn_list_img_index_list.indexOf(current_img_index);
                var next_list_index = list_index - 1;
                if (next_list_index === -1) {
                    next_list_index = nc_img_fn_list_img_index_list.length - 1;
                }
                var next_img_index = nc_img_fn_list_img_index_list[next_list_index];
                nc_show_image(next_img_index);
            } else {
                if (nc_img_fn_list_img_index_list.length === 0) {
                    show_message('Filtered file list does not any files!');
                } else {
                    nc_show_image(nc_img_fn_list_img_index_list[0]);
                }
            }

            if (typeof nc_hook_prev_image === 'function') {
                nc_hook_prev_image(current_img_index);
            }
        }
    }

    function move_to_next_image() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            if (nc_image_grid_group_var.length) {
                var last_group_index = nc_image_grid_group_var.length - 1;
                image_grid_group_next({ 'value': last_group_index }); // simulate button click
            } else {
                show_message('First, create groups by selecting items from "Group by" dropdown list');
            }
            return;
        }

        if (nc_image_count > 0) {
            var current_img_index = nc_image_index;
            if (nc_img_fn_list_img_index_list.includes(current_img_index)) {
                var list_index = nc_img_fn_list_img_index_list.indexOf(current_img_index);
                var next_list_index = list_index + 1;
                if (next_list_index === nc_img_fn_list_img_index_list.length) {
                    next_list_index = 0;
                }
                var next_img_index = nc_img_fn_list_img_index_list[next_list_index];
                nc_show_image(next_img_index);
            } else {
                if (nc_img_fn_list_img_index_list.length === 0) {
                    show_message('Filtered file list does not contain any files!');
                } else {
                    nc_show_image(nc_img_fn_list_img_index_list[0]);
                }
            }

            if (typeof nc_hook_next_image === 'function') {
                nc_hook_next_image(current_img_index);
            }
        }
    }

    function set_zoom(zoom_level_index) {
        if (zoom_level_index === NC_CANVAS_DEFAULT_ZOOM_LEVEL_INDEX) {
            nc_is_canvas_zoomed = false;
            nc_canvas_zoom_level_index = NC_CANVAS_DEFAULT_ZOOM_LEVEL_INDEX;
        } else {
            nc_is_canvas_zoomed = true;
            nc_canvas_zoom_level_index = zoom_level_index;
        }

        var zoom_scale = NC_CANVAS_ZOOM_LEVELS[nc_canvas_zoom_level_index];
        nc_reg_ctx.scale(zoom_scale, zoom_scale);

        var canvas_w = (nc_current_image.naturalWidth * zoom_scale) / nc_canvas_scale_without_zoom;
        var canvas_h = (nc_current_image.naturalHeight * zoom_scale) / nc_canvas_scale_without_zoom;
        set_canvas_size(canvas_w, canvas_h);
        nc_canvas_scale = nc_canvas_scale_without_zoom / zoom_scale;
        nc_canvas_scale = nc_canvas_scale_without_zoom / zoom_scale;

        if (zoom_scale === 1) {
            NC_REGION_POINT_RADIUS = NC_REGION_POINT_RADIUS_DEFAULT;
        } else {
            if (zoom_scale > 1) {
                NC_REGION_POINT_RADIUS = NC_REGION_POINT_RADIUS_DEFAULT * zoom_scale;
            }
        }

        nc_load_canvas_regions(); // image to canvas space transform
        nc_redraw_reg_canvas();
        nc_reg_canvas.focus();
    }

    function reset_zoom() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            image_grid_image_size_reset();
            show_message('Zoom reset');
            return;
        }

        if (!nc_current_image_loaded) {
            show_message('First load some images!');
            return;
        }

        if (nc_is_canvas_zoomed) {
            set_zoom(NC_CANVAS_DEFAULT_ZOOM_LEVEL_INDEX);
            show_message('Zoom reset');
        } else {
            show_message('Cannot reset zoom because image zoom has not been applied!');
        }
    }

    function zoom_in() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            image_grid_image_size_increase();
            show_message('Increased size of images shown in image grid');
            return;
        }

        if (!nc_current_image_loaded) {
            show_message('First load some images!');
            return;
        }

        if (nc_is_user_drawing_polygon || nc_is_user_drawing_region) {
            return;
        }

        if (nc_canvas_zoom_level_index === (NC_CANVAS_ZOOM_LEVELS.length - 1)) {
            show_message('Further zoom-in not possible');
        } else {
            var new_zoom_level_index = nc_canvas_zoom_level_index + 1;
            set_zoom(new_zoom_level_index);
            show_message('Zoomed in to ' + NC_CANVAS_ZOOM_LEVELS[nc_canvas_zoom_level_index] + 'X');
        }
    }

    function zoom_out() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            image_grid_image_size_decrease();
            show_message('Reduced size of images shown in image grid');
            return;
        }

        if (!nc_current_image_loaded) {
            show_message('First load some images!');
            return;
        }

        if (nc_is_user_drawing_polygon || nc_is_user_drawing_region) {
            return;
        }

        if (nc_canvas_zoom_level_index === 0) {
            show_message('Further zoom-out not possible');
        } else {
            var new_zoom_level_index = nc_canvas_zoom_level_index - 1;
            set_zoom(new_zoom_level_index);
            show_message('Zoomed out to level ' + NC_CANVAS_ZOOM_LEVELS[nc_canvas_zoom_level_index] + 'X');
        }
    }

    function toggle_boundary_visibility() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE) {
            nc_is_region_boundary_visible = !nc_is_region_boundary_visible;
            nc_redraw_reg_canvas();
            nc_reg_canvas.focus();
        }
    }

    function toggle_region_id_visibility() {
        nc_is_region_id_visible = !nc_is_region_id_visible;
        nc_redraw_reg_canvas();
        nc_reg_canvas.focus();
    }

    function toggle_region_info_visibility() {
        var elem = document.getElementById('region_info');
        // toggle between displaying and not displaying
        if (elem.classList.contains('display_none')) {
            elem.classList.remove('display_none');
            nc_is_region_info_visible = true;
        } else {
            elem.classList.add('display_none');
            nc_is_region_info_visible = false;
        }
    }

    // Mouse wheel event listener
    function nc_reg_canvas_mouse_wheel_listener(e) {
        if (!nc_current_image_loaded) {
            return;
        }

        if (e.ctrlKey) {
            // perform zoom
            if (e.deltaY < 0) {
                zoom_in();
            } else {
                zoom_out();
            }
            e.preventDefault();
        }
    }

    // left sidebar toolbox maintainer
    function leftsidebar_toggle() {
        var leftsidebar = document.getElementById('leftsidebar');
        if (leftsidebar.style.display === 'none') {
            leftsidebar.style.display = 'table-cell';
            document.getElementById('leftsidebar_collapse_panel').style.display = 'none';
        } else {
            leftsidebar.style.display = 'none';
            document.getElementById('leftsidebar_collapse_panel').style.display = 'table-cell';
        }
        nc_refresh();
    }

    function leftsidebar_increase_width() {
        var leftsidebar = document.getElementById('leftsidebar');
        var new_width = nc_settings.ui.leftsidebar_width + NC_LEFTSIDEBAR_WIDTH_CHANGE;
        leftsidebar.style.width = new_width + 'rem';
        nc_settings.ui.leftsidebar_width = new_width;
        if (nc_current_image_loaded) {
            nc_show_image(nc_image_index);
        }
    }

    function leftsidebar_decrease_width() {
        var leftsidebar = document.getElementById('leftsidebar');
        var new_width = nc_settings.ui.leftsidebar_width - NC_LEFTSIDEBAR_WIDTH_CHANGE;
        if (new_width >= 5) {
            leftsidebar.style.width = new_width + 'rem';
            nc_settings.ui.leftsidebar_width = new_width;
            if (nc_current_image_loaded) {
                nc_show_image(nc_image_index);
            }
        }
    }

    function leftsidebar_show() {
        var leftsidebar = document.getElementById('leftsidebar');
        leftsidebar.style.display = 'table-cell';
        document.getElementById('leftsidebar_collapse_panel').style.display = 'none';
    }

    // source: https://www.w3schools.com/howto/howto_js_accordion.asp
    function init_leftsidebar_accordion() {
        var leftsidebar = document.getElementById('leftsidebar');
        leftsidebar.style.width = nc_settings.ui.leftsidebar_width + 'rem';

        var acc = document.getElementsByClassName('leftsidebar_accordion');
        var i;
        for (i = 0; i < acc.length; ++i) {
            acc[i].addEventListener('click', function() {
                this.classList.toggle('active');
                this.nextElementSibling.classList.toggle('show');

                switch (this.innerHTML) {
                    case 'Project':
                        update_file_list();
                        break;
                }
            });
        }
    }

    // image filename list shown in leftsidebar panel
    function is_file_list_visible() {
        return file_list_panel.classList.contains('show');
    }

    function img_loading_spinbar(image_index, show) {
        var panel = document.getElementById('project_panel_title');
        if (show) {
            panel.innerHTML = 'Project <span style="margin-left:1rem;" class="loading_spinbox"></span>';
        } else {
            panel.innerHTML = 'Project';
        }
    }

    function update_file_list() {
        var regex = document.getElementById('file_list_regex').value;
        var p = document.getElementById('filelist_preset_filters_list');
        if (regex === '' || regex === null) {
            if (p.selectedIndex === 0) {
                // show all files
                nc_img_fn_list_html = [];
                nc_img_fn_list_img_index_list = [];
                nc_img_fn_list_html.push('<ul>');
                for (var i = 0; i < nc_image_filename_list.length; ++i) {
                    nc_img_fn_list_html.push(file_list_ith_entry_html(i));
                    nc_img_fn_list_img_index_list.push(i);
                }
                nc_img_fn_list_html.push('</ul>');
                img_fn_list.innerHTML = nc_img_fn_list_html.join('');

                file_list_scroll_to_current_file();
            } else {
                // filter according to preset filters
                file_list_onpreset_filter();
            }
        } else {
            file_list_generate_html(regex);
            img_fn_list.innerHTML = nc_img_fn_list_html.join('');
            file_list_scroll_to_current_file();
        }
    }

    function file_list_onregex() {
        var regex = document.getElementById('file_list_regex').value;
        file_list_generate_html(regex);
        img_fn_list.innerHTML = nc_img_fn_list_html.join('');
        file_list_scroll_to_current_file();

        // select 'regex' in the predefined filter list
        var p = document.getElementById('filelist_preset_filters_list');
        if (regex === '') {
            p.selectedIndex = 0;
        } else {
            var i;
            for (i = 0; i < p.options.length; ++i) {
                if (p.options[i].value === 'regex') {
                    p.selectedIndex = i;
                    break;
                }
            }
        }
    }

    function file_list_onpreset_filter() {
        var p = document.getElementById('filelist_preset_filters_list');
        var filter = p.options[p.selectedIndex].value;
        switch (filter) {
            case 'all':
                document.getElementById('file_list_regex').value = '';
                file_list_generate_html();
                img_fn_list.innerHTML = nc_img_fn_list_html.join('');
                file_list_scroll_to_current_file();
                break;
            case 'regex':
                document.getElementById('file_list_regex').focus();
                break;
            default:
                nc_img_fn_list_html = [];
                nc_img_fn_list_img_index_list = [];
                nc_img_fn_list_html.push('<ul>');
                var i;
                for (i = 0; i < nc_image_filename_list.length; ++i) {
                    var img_id = nc_image_id_list[i];
                    var add_to_list = false;
                    switch (filter) {
                        case 'files_without_region':
                            if (nc_image_metadata[img_id].regions.length === 0) {
                                add_to_list = true;
                            }
                            break;
                        case 'files_error_loading':
                            if (nc_image_load_error[i] === true) {
                                add_to_list = true;
                            }
                    }
                    if (add_to_list) {
                        nc_img_fn_list_html.push(file_list_ith_entry_html(i));
                        nc_img_fn_list_img_index_list.push(i);
                    }
                }
                nc_img_fn_list_html.push('</ul>');
                img_fn_list.innerHTML = nc_img_fn_list_html.join('');
                file_list_scroll_to_current_file();
                break;
        }
    }

    function file_list_ith_entry_selected(img_index, is_selected) {
        if (is_selected) {
            file_list_ith_entry_add_css_class(img_index, 'sel');
        } else {
            file_list_ith_entry_remove_css_class(img_index, 'sel');
        }
    }

    function file_list_ith_entry_error(img_index, is_error) {
        if (is_error) {
            file_list_ith_entry_add_css_class(img_index, 'error');
        } else {
            file_list_ith_entry_remove_css_class(img_index, 'error');
        }
    }

    function file_list_ith_entry_add_css_class(img_index, classname) {
        var li = document.getElementById('fl' + img_index);
        if (li && !li.classList.contains(classname)) {
            li.classList.add(classname);
        }
    }

    function file_list_ith_entry_remove_css_class(img_index, classname) {
        var li = document.getElementById('fl' + img_index);
        if (li && li.classList.contains(classname)) {
            li.classList.remove(classname);
        }
    }

    function file_list_clear_all_style() {
        var cn = document.getElementById('img_fn_list').childNodes[0].childNodes;
        var i, j;
        var n = cn.length;
        var nclass;
        for (i = 0; i < n; ++i) {
            //cn[i].classList = []; // throws error in Edge browser
            nclass = cn[i].classList.length;
            if (nclass) {
                for (j = 0; j < nclass; ++j) {
                    cn[i].classList.remove(cn[i].classList.item(j));
                }
            }
        }
    }

    function file_list_clear_css_classname(classname) {
        var cn = document.getElementById('img_fn_list').childNodes[0].childNodes;
        var i;
        var n = cn.length;
        for (i = 0; i < n; ++i) {
            if (cn[i].classList.contains(classname)) {
                cn[i].classList.remove(classname);
            }
        }
    }

    function file_list_ith_entry_html(i) {
        var htmli = '';
        var filename = nc_image_filename_list[i];
        if (is_url(filename)) {
            filename = filename.substr(0, 4) + '...' + get_filename_from_url(filename);
        }

        htmli += '<li id="fl' + i + '"';
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            if (nc_image_grid_page_img_index_list.includes(i)) {
                // highlight images being shown in image grid
                htmli += ' class="sel"';
            }

        } else {
            if (i === nc_image_index) {
                // highlight the current entry
                htmli += ' class="sel"';
            }
        }
        htmli += ' onclick="jump_to_image(' + (i) + ')" title="' + nc_image_filename_list[i] + '">[' + (i + 1) + '] ' + decodeURIComponent(filename) + '</li>';
        return htmli;
    }

    function file_list_generate_html(regex) {
        nc_img_fn_list_html = [];
        nc_img_fn_list_img_index_list = [];
        nc_img_fn_list_html.push('<ul>');
        for (var i = 0; i < nc_image_filename_list.length; ++i) {
            var filename = nc_image_filename_list[i];
            if (filename.match(regex) !== null) {
                nc_img_fn_list_html.push(file_list_ith_entry_html(i));
                nc_img_fn_list_img_index_list.push(i);
            }
        }
        nc_img_fn_list_html.push('</ul>');
    }

    function file_list_scroll_to_current_file() {
        file_list_scroll_to_file(nc_image_index);
    }

    function file_list_scroll_to_file(file_index) {
        if (nc_img_fn_list_img_index_list.includes(file_index)) {
            var sel_file = document.getElementById('fl' + file_index);
            var panel_height = img_fn_list.clientHeight - 20;
            var window_top = img_fn_list.scrollTop;
            var window_bottom = img_fn_list.scrollTop + panel_height
            if (sel_file.offsetTop > window_top) {
                if (sel_file.offsetTop > window_bottom) {
                    img_fn_list.scrollTop = sel_file.offsetTop;
                }
            } else {
                img_fn_list.scrollTop = sel_file.offsetTop - panel_height;
            }
        }
    }

    function toggle_file_list_visibility() {
        leftsidebar_show();
        document.getElementById('file_list_panel').classList.toggle('show');
        document.getElementById('project_panel_title').classList.toggle('active');
    }

    // invoke a method after receiving inputs from user
    function invoke_with_user_inputs(ok_handler, input, config, cancel_handler) {
        setup_user_input_panel(ok_handler, input, config, cancel_handler);
        show_user_input_panel();
    }

    function setup_user_input_panel(ok_handler, input, config, cancel_handler) {
        // create html page with OK and CANCEL button
        // when OK is clicked
        //  - setup input with all the user entered values
        //  - invoke handler with input
        // when CANCEL is clicked
        //  - invoke user_input_cancel()
        nc_user_input_ok_handler = ok_handler;
        nc_user_input_cancel_handler = cancel_handler;
        nc_user_input_data = input;

        var p = document.getElementById('user_input_panel');
        var c = document.createElement('div');
        c.setAttribute('class', 'content');
        var html = [];
        html.push('<p class="title">' + config.title + '</p>');

        html.push('<div class="user_inputs">');
        var key;
        for (key in nc_user_input_data) {
            html.push('<div class="row">');
            html.push('<span class="cell">' + nc_user_input_data[key].name + '</span>');
            var disabled_html = '';
            if (nc_user_input_data[key].disabled) {
                disabled_html = 'disabled="disabled"';
            }
            var value_html = '';
            if (nc_user_input_data[key].value) {
                value_html = 'value="' + nc_user_input_data[key].value + '"';
            }

            switch (nc_user_input_data[key].type) {
                case 'checkbox':
                    if (nc_user_input_data[key].checked) {
                        value_html = 'checked="checked"';
                    } else {
                        value_html = '';
                    }
                    html.push('<span class="cell">' +
                        '<input class="nc_user_input_variable" ' +
                        value_html + ' ' +
                        disabled_html + ' ' +
                        'type="checkbox" id="' + key + '"></span>');
                    break;
                case 'text':
                    var size = '50';
                    if (nc_user_input_data[key].size) {
                        size = nc_user_input_data[key].size;
                    }
                    var placeholder = '';
                    if (nc_user_input_data[key].placeholder) {
                        placeholder = nc_user_input_data[key].placeholder;
                    }
                    html.push('<span class="cell">' +
                        '<input class="nc_user_input_variable" ' +
                        value_html + ' ' +
                        disabled_html + ' ' +
                        'size="' + size + '" ' +
                        'placeholder="' + placeholder + '" ' +
                        'type="text" id="' + key + '"></span>');

                    break;
                case 'textarea':
                    var rows = '5';
                    var cols = '50'
                    if (nc_user_input_data[key].rows) {
                        rows = nc_user_input_data[key].rows;
                    }
                    if (nc_user_input_data[key].cols) {
                        cols = nc_user_input_data[key].cols;
                    }
                    var placeholder = '';
                    if (nc_user_input_data[key].placeholder) {
                        placeholder = nc_user_input_data[key].placeholder;
                    }
                    html.push('<span class="cell">' +
                        '<textarea class="nc_user_input_variable" ' +
                        disabled_html + ' ' +
                        'rows="' + rows + '" ' +
                        'cols="' + cols + '" ' +
                        'placeholder="' + placeholder + '" ' +
                        'id="' + key + '">' + value_html + '</textarea></span>');

                    break;

            }
            html.push('</div>'); // end of row
        }
        html.push('</div>'); // end of user_input div
        // optional warning before confirmation
        if (config.hasOwnProperty("warning")) {
            html.push('<div class="warning">' + config.warning + '</div>');
        }
        html.push('<div class="user_confirm">' +
            '<span class="ok">' +
            '<button id="user_input_ok_button" onclick="user_input_parse_and_invoke_handler()">&nbsp;OK&nbsp;</button></span>' +
            '<span class="cancel">' +
            '<button id="user_input_cancel_button" onclick="user_input_cancel_handler()">CANCEL</button></span></div>');
        c.innerHTML = html.join('');
        p.innerHTML = '';
        p.appendChild(c);

    }

    function user_input_default_cancel_handler() {
        hide_user_input_panel();
        nc_user_input_data = {};
        nc_user_input_ok_handler = null;
        nc_user_input_cancel_handler = null;
    }

    function user_input_cancel_handler() {
        if (nc_user_input_cancel_handler) {
            nc_user_input_cancel_handler();
        }
        user_input_default_cancel_handler();
    }

    function user_input_parse_and_invoke_handler() {
        var elist = document.getElementsByClassName('nc_user_input_variable');
        var i;
        for (i = 0; i < elist.length; ++i) {
            var eid = elist[i].id;
            if (nc_user_input_data.hasOwnProperty(eid)) {
                switch (nc_user_input_data[eid].type) {
                    case 'checkbox':
                        nc_user_input_data[eid].value = elist[i].checked;
                        break;
                    default:
                        nc_user_input_data[eid].value = elist[i].value;
                        break;
                }
            }
        }
        if (typeof(nc_user_input_data.confirm) !== 'undefined') {
            if (nc_user_input_data.confirm.value) {
                nc_user_input_ok_handler(nc_user_input_data);
            } else {
                if (nc_user_input_cancel_handler) {
                    nc_user_input_cancel_handler();
                }
            }
        } else {
            nc_user_input_ok_handler(nc_user_input_data);
        }
        user_input_default_cancel_handler();
    }

    function show_user_input_panel() {
        document.getElementById('user_input_panel').style.display = 'block';
    }

    function hide_user_input_panel() {
        document.getElementById('user_input_panel').style.display = 'none';
    }

    // nc project
    function refresh_project_name() {
        var p = document.getElementById('project_name');
        p.value = nc_settings.project.name;
    }

    function refresh_region_color_picker() {
        var p = document.getElementById("region_color_picker");
        if (p) {
            p.value = nc_settings.ui.image.region_color;
        }
    }

    function project_set_name(name) {
        nc_settings.project.name = name;
        refresh_project_name();
    }

    function project_init_default_project() {
        if (!nc_settings.hasOwnProperty('project')) {
            nc_settings.project = {};
        }

        project_set_name(get_default_project_name());
    }

    function change_project_name(p) {
        project_set_name(p.value);
    }

    function number_padding_with_zeros(num, n) {
        var len = num.toString().length;
        while (len < n) {
            num = "0" + num;
            len++;
        }
        return num;
    }

    function get_default_project_name() {
        const now = new Date();
        var ts = now.getFullYear() + number_padding_with_zeros(now.getMonth() + 1, 2) + number_padding_with_zeros(now.getDate(), 2) +
            '_' + number_padding_with_zeros(now.getHours(), 2) + number_padding_with_zeros(now.getMinutes(), 2);

        var project_name = 'project_' + ts;
        return project_name;
    }

    function save_project_with_confirm() {
        var config = { 'title': 'Save Project' };
        var input = {
            'project_name': { type: 'text', name: 'Project Name', value: nc_settings.project.name, disabled: false, size: 30 },
            'save_annotations': { type: 'checkbox', name: 'Save region annotations (i.e. manual annotations)', checked: true, disabled: false },
            'savenc_settings': { type: 'checkbox', name: 'Save settings', checked: true },
        };

        invoke_with_user_inputs(project_save_confirmed, input, config);
    }

    function project_save_confirmed(input) {
        if (input.project_name.value !== nc_settings.project.name) {
            project_set_name(input.project_name.value);
        }

        // nc project
        var nc_project = {
            'nc_settings': nc_settings,
            'nc_data_format_version': NC_VERSION,
            'nc_image_id_list': nc_image_id_list,
            'nc_image_metadata': nc_image_metadata
        };

        var filename = input.project_name.value + '.json';
        var data_blob = new Blob([JSON.stringify(nc_project, undefined, 2)], { type: 'text/json;charset=utf-8' });

        save_data_to_local_file(data_blob, filename);

        user_input_default_cancel_handler();
    }

    function open_project_from_json_file() {
        if (invisible_file_input) {
            invisible_file_input.accept = '.json';
            invisible_file_input.onchange = project_open;
            invisible_file_input.removeAttribute('multiple');
            invisible_file_input.click();
        }
    }

    function project_open(event) {
        var selected_file = event.target.files[0];
        load_text_file(selected_file, project_open_parse_json_file);
    }

    function project_open_parse_json_file(project_file_data) {
        var d = JSON.parse(project_file_data);
        if (d['nc_settings'] && d['nc_image_metadata']) {
            // import settings
            project_import_settings(d['nc_settings']);

            // clear existing data (if any)
            nc_image_id_list = [];
            nc_image_filename_list = [];
            // nc_image_index = 0; ???
            nc_image_count = 0;
            nc_image_metadata = {};
            nc_image_fileref = {};
            nc_image_src = {};
            nc_buffer_remove_all();

            // import image metadata
            nc_image_metadata = {};
            for (var img_id in d['nc_image_metadata']) {
                if ('filename' in d['nc_image_metadata'][img_id] &&
                    'size' in d['nc_image_metadata'][img_id] &&
                    'regions' in d['nc_image_metadata'][img_id]) {
                    if (!d.hasOwnProperty('nc_image_id_list')) {
                        nc_image_id_list.push(img_id);
                        nc_image_filename_list.push(d['nc_image_metadata'][img_id].filename);
                    }

                    nc_image_metadata[img_id] = d['nc_image_metadata'][img_id];
                    nc_image_count += 1;
                } else {
                    console.log('discarding malformed entry for ' + img_id +
                        ': ' + JSON.stringify(d['nc_image_metadata'][img_id]));
                }
            }


            // import image_id_list which records the order of images
            if (d.hasOwnProperty('nc_image_id_list')) {
                nc_image_id_list = d['nc_image_id_list'];
                for (var img_id_index in d['nc_image_id_list']) {
                    var img_id = d['nc_image_id_list'][img_id_index];
                    nc_image_filename_list.push(nc_image_metadata[img_id]['filename']);
                }
            }

            if (nc_settings.core.default_filepath !== '') {
                nc_file_resolve_all_to_default_filepath();
            }

            if (nc_image_count > 0) {
                nc_show_image(0);
                update_file_list();
            }
            refresh_project_name();
            refresh_region_color_picker();

            show_message('Imported project [' + nc_settings['project'].name + '] with ' + nc_image_count + ' files.');
        } else {
            show_message('Cannot import project from a corrupt file!');
        }
    }

    function project_import_settings(s) {
        // @todo find a generic way to import into nc_settings
        var k1;
        for (k1 in s) {
            if (typeof(s[k1]) === 'object') {
                var k2;
                for (k2 in s[k1]) {
                    if (typeof(s[k1][k2]) === 'object') {
                        var k3;
                        for (k3 in s[k1][k2]) {
                            nc_settings[k1][k2][k3] = s[k1][k2][k3];
                        }
                    } else {
                        nc_settings[k1][k2] = s[k1][k2];
                    }
                }
            } else {
                nc_settings[k1] = s[k1];
            }
        }
    }

    function project_remove_file() {
        var img_id = nc_image_id_list[nc_image_index];
        var filename = nc_image_metadata[img_id].filename;
        var region_count = nc_image_metadata[img_id].regions.length;

        var config = { 'title': 'Remove File from Project' };
        var input = {
            'img_index': { type: 'text', name: 'File Id', value: (nc_image_index + 1), disabled: true, size: 8 },
            'filename': { type: 'text', name: 'Filename', value: filename, disabled: true, size: 30 },
            'region_count': { type: 'text', name: 'Number of regions', disabled: true, value: region_count, size: 8 }
        };

        invoke_with_user_inputs(project_file_remove_confirmed, input, config);
    }

    function project_file_remove_confirmed(input) {
        var img_index = input.img_index.value - 1;

        project_remove_one_file(img_index);

        if (img_index === nc_image_count) {
            if (nc_image_count === 0) {
                nc_current_image_loaded = false;
                show_home_panel();
            } else {
                nc_show_image(img_index - 1);
            }
        } else {
            nc_show_image(img_index);
        }
        update_file_list();
        show_message('Removed file [' + input.filename.value + '] from project');
        user_input_default_cancel_handler();
    }

    function project_remove_one_file(img_index) {
        if (img_index < 0 || img_index >= nc_image_count) {
            console.log('project_remove_file(): invalid img_index ' + img_index);
            return;
        }
        var img_id = nc_image_id_list[img_index];

        // remove img_index from all array
        // this invalidates all image_index > img_index
        nc_image_id_list.splice(img_index, 1);
        nc_image_filename_list.splice(img_index, 1);

        var img_fn_list_index = nc_img_fn_list_img_index_list.indexOf(img_index);
        if (img_fn_list_index !== -1) {
            nc_img_fn_list_img_index_list.splice(img_fn_list_index, 1);
        }

        // clear all buffer
        // @todo: it is wasteful to clear all the buffer instead of removing a single image
        nc_buffer_remove_all();
        file_list_clear_css_classname('buffered');

        nc_clear_reg_canvas();
        delete nc_image_metadata[img_id];
        delete nc_image_src[img_id];
        delete nc_image_fileref[img_id];

        nc_image_count -= 1;
    }

    function project_add_new_file(filename, size, file_id) {
        var img_id = file_id;
        if (typeof(img_id) === 'undefined') {
            size = get_default_value(size, -1);
            img_id = nc_get_image_id(filename, size);
        }

        if (!nc_image_metadata.hasOwnProperty(img_id)) {
            nc_image_metadata[img_id] = new file_metadata(filename, size);
            nc_image_id_list.push(img_id);
            nc_image_filename_list.push(filename);
            nc_image_count += 1;
        }
        return img_id;
    }

    function project_file_add_local(event) {
        var user_selected_images = event.target.files;
        var original_image_count = nc_image_count;

        var new_img_index_list = [];
        var discarded_file_count = 0;
        for (var i = 0; i < user_selected_images.length; ++i) {
            var filetype = user_selected_images[i].type.substr(0, 5);
            if (filetype === 'image') {
                // check which filename in project matches the user selected file
                var img_index = nc_image_filename_list.indexOf(user_selected_images[i].name);
                if (img_index === -1) {
                    // a new file was added to project
                    var new_img_id = project_add_new_file(user_selected_images[i].name,
                        user_selected_images[i].size);
                    nc_image_fileref[new_img_id] = user_selected_images[i];
                    new_img_index_list.push(nc_image_id_list.indexOf(new_img_id));
                } else {
                    // an existing file was resolved using browser's file selector
                    var img_id = nc_image_id_list[img_index];
                    nc_image_fileref[img_id] = user_selected_images[i];
                    nc_image_metadata[img_id]['size'] = user_selected_images[i].size;
                }
            } else {
                discarded_file_count += 1;
            }
        }

        if (nc_image_metadata) {
            var status_msg = 'Loaded ' + new_img_index_list.length + ' images.';
            if (discarded_file_count) {
                status_msg += ' ( Discarded ' + discarded_file_count + ' non-image files ! )';
            }
            show_message(status_msg);

            if (new_img_index_list.length) {
                // show first of newly added image
                nc_show_image(new_img_index_list[0]);
            } else {
                // show original image
                nc_show_image(nc_image_index);
            }
            update_file_list();
        } else {
            show_message("Please upload some image files!");
        }
    }

    function project_file_load_on_fail(img_index) {
        var img_id = nc_image_id_list[img_index];
        nc_image_src[img_id] = '';
        nc_image_load_error[img_index] = true;
        file_list_ith_entry_error(img_index, true);
    }

    function project_file_load_on_success(img_index) {
        nc_image_load_error[img_index] = false;
        file_list_ith_entry_error(img_index, false);
    }

    // image grid
    function image_grid_init() {
        var p = document.getElementById('image_grid_content');
        p.focus();
        p.addEventListener('mousedown', image_grid_mousedown_handler, false);
        p.addEventListener('mouseup', image_grid_mouseup_handler, false);
        p.addEventListener('dblclick', image_grid_dblclick_handler, false);

        image_grid_set_content_panel_height_fixed();

        // select policy as defined in settings
        var i, option;
        var p = document.getElementById('image_grid_show_image_policy');
        var n = p.options.length;
        for (i = 0; i < n; ++i) {
            if (p.options[i].value === nc_settings.ui.image_grid.show_image_policy) {
                p.selectedIndex = i;
                break;
            }
        }
    }

    function image_grid_update() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            image_grid_set_content(nc_image_grid_img_index_list);
        }
    }

    function toggle_grid_images() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE_GRID) {
            image_grid_clear_all_groups();
            view_single_image();
        } else {
            view_grid_images();
        }
    }

    function image_grid_show_all_images() {
        var all_img_index_list = [];
        var i, n;
        //n = nc_image_id_list.length;
        n = nc_img_fn_list_img_index_list.length;
        for (i = 0; i < n; ++i) {
            all_img_index_list.push(nc_img_fn_list_img_index_list[i]);
        }
        image_grid_clear_all_groups();

        var p = document.getElementById('image_grid_toolbar_group_by_select');
        p.selectedIndex = 0;

        image_grid_set_content(all_img_index_list);
    }

    function image_grid_clear_all_groups() {
        var i, n;
        n = nc_image_grid_group_var.length;
        for (i = 0; i < n; ++i) {
            image_grid_remove_html_group_panel(nc_image_grid_group_var[i]);
            image_grid_group_by_select_set_disabled(nc_image_grid_group_var[i].type,
                nc_image_grid_group_var[i].name,
                false);
        }
        nc_image_grid_group = {};
        nc_image_grid_group_var = [];
    }

    function image_grid_set_content(img_index_list) {
        if (img_index_list.length === 0) {
            return;
        }
        if (nc_image_grid_load_ongoing) {
            return;
        }

        nc_image_grid_img_index_list = img_index_list.slice(0);
        nc_image_grid_selected_img_index_list = img_index_list.slice(0);

        document.getElementById('image_grid_group_by_img_count').innerHTML = nc_image_grid_img_index_list.length;

        nc_image_grid_page_first_index = 0;
        nc_image_grid_page_last_index = null;
        nc_image_grid_stack_prev_page = [];
        nc_image_grid_page_img_index_list = [];

        image_grid_clear_content();
        image_grid_set_content_panel_height_fixed();
        nc_image_grid_load_ongoing = true;

        var n = nc_image_grid_img_index_list.length;
        switch (nc_settings.ui.image_grid.show_image_policy) {
            case 'all':
                nc_image_grid_page_img_index_list = nc_image_grid_img_index_list.slice(0);
                break;
            case 'first_mid_last':
                if (n < 3) {
                    var i;
                    for (i = 0; i < n; ++i) {
                        nc_image_grid_page_img_index_list.push(nc_image_grid_img_index_list[i]);
                    }
                } else {
                    nc_image_grid_page_img_index_list.push(nc_image_grid_img_index_list[0]);
                    nc_image_grid_page_img_index_list.push(nc_image_grid_img_index_list[Math.floor(n / 2)]);
                    nc_image_grid_page_img_index_list.push(nc_image_grid_img_index_list[n - 1]);
                }
                break;
            case 'even_indexed':
                var i;
                for (i = 0; i < n; ++i) {
                    if (i % 2 !== 0) { // since the user views (i+1) based indexing
                        nc_image_grid_page_img_index_list.push(nc_image_grid_img_index_list[i]);
                    }
                }
                break;
            case 'odd_indexed':
                var i;
                for (i = 0; i < n; ++i) {
                    if (i % 2 === 0) { // since the user views (i+1) based indexing
                        nc_image_grid_page_img_index_list.push(nc_image_grid_img_index_list[i]);
                    }
                }
                break;
            case 'gap5': // fallback
            case 'gap25': // fallback
            case 'gap50': // fallback
                var del = parseInt(nc_settings.ui.image_grid.show_image_policy.substr('gap'.length));
                var i;
                for (i = 0; i < n; i = i + del) {
                    nc_image_grid_page_img_index_list.push(nc_image_grid_img_index_list[i]);
                }
                break;
        }

        nc_image_grid_visible_img_index_list = [];

        image_grid_update_sel_count_html();

        image_grid_content_append_img(nc_image_grid_page_first_index);

        show_message('[Click] toggles selection, ' +
            '[Shift + Click] selects everything a image, ' +
            '[Click] or [Ctrl + Click] removes selection of all subsequent or preceeding images.');
    }

    function image_grid_clear_content() {
        // <div id="image_grid_content">
        //    <div id="image_grid_content_image_list_set"> ...IMAGE1 ... IMAGEn  </div>
        // </div>
        var img_container = document.getElementById('image_grid_content_image_list_set');
        img_container.innerHTML = '';
        nc_image_grid_visible_img_index_list = [];
    }

    function image_grid_set_content_panel_height_fixed() {
        var pc = document.getElementById('image_grid_content');
        var de = document.documentElement;
        pc.style.height = (de.clientHeight - 5.5 * ui_top_panel.offsetHeight) + 'px';
    }

    // We do not know how many images will fit in the display area.
    // Therefore, we add images one-by-one until overflow of parent
    // container is detected.
    function image_grid_content_append_img(img_grid_index) {
        var img_index = nc_image_grid_page_img_index_list[img_grid_index];
        var html_img_id = image_grid_get_html_img_id(img_index);
        var img_id = nc_image_id_list[img_index];
        var e = document.createElement('img');
        if (nc_image_fileref[img_id] instanceof File) {
            var img_reader = new FileReader();
            img_reader.addEventListener("error", function() {
                //@todo
            }, false);
            img_reader.addEventListener("load", function() {
                e.src = img_reader.result;
            }, false);
            img_reader.readAsDataURL(nc_image_fileref[img_id]);
        } else {
            e.src = nc_image_src[img_id];
        }
        e.setAttribute('id', html_img_id);
        e.setAttribute('height', nc_settings.ui.image_grid.img_height + 'px');
        e.setAttribute('title', '[' + (img_index + 1) + '] ' + nc_image_metadata[img_id].filename);

        e.addEventListener('load', image_grid_on_img_load, false);
        e.addEventListener('error', image_grid_on_img_error, false);
        document.getElementById('image_grid_content_image_list_set').appendChild(e);
    }

    function image_grid_on_img_load(e) {
        var img = e.target;
        var img_index = image_grid_parse_html_img_id(img.id);
        project_file_load_on_success(img_index);

        image_grid_add_image_if_possible(img);
    }

    function image_grid_on_img_error(e) {
        var img = e.target;
        var img_index = image_grid_parse_html_img_id(img.id);
        project_file_load_on_fail(img_index);
        image_grid_add_image_if_possible(img);
    }

    function image_grid_add_image_if_possible(img) {
        var img_index = image_grid_parse_html_img_id(img.id);

        var p = document.getElementById('image_grid_content_image_list_set');
        var img_bottom_right_corner = parseInt(img.offsetTop) + parseInt(img.height);
        if (p.clientHeight < img_bottom_right_corner) {
            // stop as addition of this image caused overflow of parent container
            var img_container = document.getElementById('image_grid_content_image_list_set');
            img_container.removeChild(img);

            nc_image_grid_load_ongoing = false;

            var index = nc_image_grid_page_img_index_list.indexOf(img_index);
            nc_image_grid_page_last_index = index;

            // setup prev, next navigation
            var info = document.getElementById('image_grid_nav');
            var html = [];
            var first_index = nc_image_grid_page_first_index;
            var last_index = nc_image_grid_page_last_index - 1;
            html.push('<span>Showing&nbsp;' + (first_index + 1) +
                ' to ' + (last_index + 1) + '&nbsp;:</span>');
            if (nc_image_grid_stack_prev_page.length) {
                html.push('<span class="text_button" onclick="image_grid_page_prev()">Prev</span>');
            } else {
                html.push('<span>Prev</span>');
            }
            html.push('<span class="text_button" onclick="image_grid_page_next()">Next</span');
            info.innerHTML = html.join('');
        } else {
            // process this image and trigger addition of next image in sequence
            var img_fn_list_index = nc_image_grid_page_img_index_list.indexOf(img_index);
            var next_img_fn_list_index = img_fn_list_index + 1;

            nc_image_grid_visible_img_index_list.push(img_index);
            var is_selected = (nc_image_grid_selected_img_index_list.indexOf(img_index) !== -1);
            if (!is_selected) {
                image_grid_update_img_select(img_index, 'unselect');
            }

            if (next_img_fn_list_index !== nc_image_grid_page_img_index_list.length) {
                if (nc_image_grid_load_ongoing) {
                    image_grid_content_append_img(img_fn_list_index + 1);
                } else {
                    // image grid load operation was cancelled
                    nc_image_grid_page_last_index = nc_image_grid_page_first_index; // load this page again

                    var info = document.getElementById('image_grid_nav');
                    var html = [];
                    html.push('<span>Cancelled&nbsp;:</span>');
                    if (nc_image_grid_stack_prev_page.length) {
                        html.push('<span class="text_button" onclick="image_grid_page_prev()">Prev</span>');
                    } else {
                        html.push('<span>Prev</span>');
                    }
                    html.push('<span class="text_button" onclick="image_grid_page_next()">Next</span');
                    info.innerHTML = html.join('');
                }
            } else {
                // last page
                var index = nc_image_grid_page_img_index_list.indexOf(img_index);
                nc_image_grid_page_last_index = index;

                nc_image_grid_load_ongoing = false;

                // setup prev, next navigation
                var info = document.getElementById('image_grid_nav');
                var html = [];
                var first_index = nc_image_grid_page_first_index;
                var last_index = nc_image_grid_page_last_index;
                html.push('<span>Showing&nbsp;' + (first_index + 1) +
                    ' to ' + (last_index + 1) + ' (end)&nbsp;</span>');
                if (nc_image_grid_stack_prev_page.length) {
                    html.push('<span class="text_button" onclick="image_grid_page_prev()">Prev</span>');
                } else {
                    html.push('<span>Prev</span>');
                }
                html.push('<span>Next</span');

                info.innerHTML = html.join('');
            }
        }
    }

    function image_grid_onchange_show_image_policy(p) {
        nc_settings.ui.image_grid.show_image_policy = p.options[p.selectedIndex].value;
        image_grid_set_content(nc_image_grid_img_index_list);
    }

    function image_grid_image_size_increase() {
        var new_img_height = nc_settings.ui.image_grid.img_height + NC_IMAGE_GRID_IMG_HEIGHT_CHANGE;
        nc_settings.ui.image_grid.img_height = new_img_height;

        nc_image_grid_page_last_index = null;
        image_grid_update();
    }

    function image_grid_image_size_decrease() {
        var new_img_height = nc_settings.ui.image_grid.img_height - NC_IMAGE_GRID_IMG_HEIGHT_CHANGE;
        if (new_img_height > 1) {
            nc_settings.ui.image_grid.img_height = new_img_height;
            nc_image_grid_page_last_index = null;
            image_grid_update();
        }
    }

    function image_grid_image_size_reset() {
        var new_img_height = nc_settings.ui.image_grid.img_height;
        if (new_img_height > 1) {
            nc_settings.ui.image_grid.img_height = new_img_height;
            nc_image_grid_page_last_index = null;
            image_grid_update();
        }
    }

    function image_grid_mousedown_handler(e) {
        // here e.target == image_grid_content !!!!
        e.preventDefault();
        nc_image_grid_mousedown_img_index = image_grid_parse_html_img_id(e.target.id);
    }

    function image_grid_mouseup_handler(e) {
        // here e.target == image_grid_content !!!!
        e.preventDefault();
        var last_mouseup_img_index = nc_image_grid_mouseup_img_index;
        nc_image_grid_mouseup_img_index = image_grid_parse_html_img_id(e.target.id);

        if (isNaN(nc_image_grid_mousedown_img_index) ||
            isNaN(nc_image_grid_mouseup_img_index)) {
            last_mouseup_img_index = nc_image_grid_img_index_list[0];
            image_grid_group_select_none();
            return;
        }

        var mousedown_img_arr_index = nc_image_grid_img_index_list.indexOf(nc_image_grid_mousedown_img_index);
        var mouseup_img_arr_index = nc_image_grid_img_index_list.indexOf(nc_image_grid_mouseup_img_index);

        var start = -1;
        var end = -1;
        var operation = 'select'; // {'select', 'unselect', 'toggle'}
        if (mousedown_img_arr_index === mouseup_img_arr_index) {
            if (e.shiftKey) {
                // select all elements until this element
                start = nc_image_grid_img_index_list.indexOf(last_mouseup_img_index) + 1;
                end = mouseup_img_arr_index + 1;
            } else {
                // toggle selection of single image
                start = mousedown_img_arr_index;
                end = start + 1;
                operation = 'toggle';
            }
        } else {
            if (mousedown_img_arr_index < mouseup_img_arr_index) {
                start = mousedown_img_arr_index;
                end = mouseup_img_arr_index + 1;
            } else {
                start = mouseup_img_arr_index + 1;
                end = mousedown_img_arr_index;
            }
            operation = 'toggle';
        }

        if (start > end) {
            return;
        }

        var i, img_index;
        for (i = start; i < end; ++i) {
            img_index = nc_image_grid_img_index_list[i];
            image_grid_update_img_select(img_index, operation);
        }
        image_grid_update_sel_count_html();
    }

    function image_grid_update_sel_count_html() {
        document.getElementById('image_grid_group_by_sel_img_count').innerHTML = nc_image_grid_selected_img_index_list.length;
    }

    // state in {'select', 'unselect', 'toggle'}
    function image_grid_update_img_select(img_index, state) {
        var html_img_id = image_grid_get_html_img_id(img_index);
        var is_selected = (nc_image_grid_selected_img_index_list.indexOf(img_index) !== -1);
        if (state === 'toggle') {
            if (is_selected) {
                state = 'unselect';
            } else {
                state = 'select';
            }
        }

        switch (state) {
            case 'select':
                if (!is_selected) {
                    nc_image_grid_selected_img_index_list.push(img_index);
                }
                if (nc_image_grid_visible_img_index_list.indexOf(img_index) !== -1) {
                    document.getElementById(html_img_id).classList.remove('not_sel');
                }
                break;
            case 'unselect':
                if (is_selected) {
                    var arr_index = nc_image_grid_selected_img_index_list.indexOf(img_index);
                    nc_image_grid_selected_img_index_list.splice(arr_index, 1);
                }
                if (nc_image_grid_visible_img_index_list.indexOf(img_index) !== -1) {
                    document.getElementById(html_img_id).classList.add('not_sel');
                }
                break;
        }
    }

    function image_grid_group_select_all() {
        image_grid_group_set_all_selection_state('select');
        image_grid_update_sel_count_html();
        show_message('Selected all images in current group');
    }

    function image_grid_group_select_none() {
        image_grid_group_set_all_selection_state('unselect');
        image_grid_update_sel_count_html();
        show_message('Removed selection of all images in current group');
    }

    function image_grid_group_set_all_selection_state(state) {
        var i, img_index;
        for (i = 0; i < nc_image_grid_img_index_list.length; ++i) {
            img_index = nc_image_grid_img_index_list[i];
            image_grid_update_img_select(img_index, state);
        }
    }

    function image_grid_group_toggle_select_all() {
        if (nc_image_grid_selected_img_index_list.length === nc_image_grid_img_index_list.length) {
            image_grid_group_select_none();
        } else {
            image_grid_group_select_all();
        }
    }

    function image_grid_parse_html_img_id(html_img_id) {
        // html_img_id -- image_grid_content
        var img_index = html_img_id.substr(2);
        return parseInt(img_index);
    }

    function image_grid_get_html_img_id(img_index) {
        return 'im' + img_index;
    }

    function image_grid_parse_html_region_id(html_region_id) {
        var chunks = html_region_id.split('_');
        if (chunks.length === 2) {
            var img_index = parseInt(chunks[0].substr(2));
            var region_id = parseInt(chunks[1].substr(2));
            return { 'img_index': img_index, 'region_id': region_id };
        } else {
            console.log('image_grid_parse_html_region_id(): invalid html_region_id');
            return {};
        }
    }

    function image_grid_dblclick_handler(e) {
        // here e.target == image_grid_content !!!!
        nc_image_index = image_grid_parse_html_img_id(e.target.id);
        view_single_image();
    }

    function image_grid_toolbar_update_group_by_select() {
        var p = document.getElementById('image_grid_toolbar_group_by_select');
        p.innerHTML = '';

        var o = document.createElement('option');
        o.setAttribute('value', '');
        o.setAttribute('selected', 'selected');
        o.innerHTML = 'All Images';
        p.appendChild(o);
    }

    function image_grid_toolbar_group_by_select_get_html_id(type, name) {
        if (type === 'file') {
            return 'f_' + name;
        }
        if (type === 'region') {
            return 'r_' + name;
        }
    }

    function image_grid_toolbar_group_by_select_parse_html_id(id) {
        if (id.startsWith('f_')) {
            return { 'attr_type': 'file', 'attr_name': id.substr(2) };
        }
        if (id.startsWith('r_')) {
            return { 'attr_type': 'region', 'attr_name': id.substr(2) };
        }
    }

    function image_grid_onchange_group_by_select(p) {
        if (p.options[p.selectedIndex].value === '') {
            image_grid_show_all_images();
            return;
        }

        var v = image_grid_toolbar_group_by_select_parse_html_id(p.options[p.selectedIndex].value);
        var attr_type = v.attr_type;
        var attr_name = v.attr_name;
        image_grid_group_by(attr_type, attr_name);

        image_grid_group_by_select_set_disabled(attr_type, attr_name, true);
        p.blur(); // to avoid adding new groups using keyboard keys as dropdown is still in focus
    }

    function image_grid_remove_html_group_panel(d) {
        var p = document.getElementById('group_toolbar_' + d.group_index);
        document.getElementById('image_grid_group_panel').removeChild(p);
    }

    function image_grid_add_html_group_panel(d) {
        var p = document.createElement('div');
        p.classList.add('image_grid_group_toolbar');
        p.setAttribute('id', 'group_toolbar_' + d.group_index);

        var del = document.createElement('span');
        del.classList.add('text_button');
        del.setAttribute('onclick', 'image_grid_remove_group_by(this)');
        del.innerHTML = '&times;';
        p.appendChild(del);

        var prev = document.createElement('button');
        prev.innerHTML = '<';
        prev.setAttribute('value', d.group_index);
        prev.setAttribute('onclick', 'image_grid_group_prev(this)');
        p.appendChild(prev);

        var sel = document.createElement('select');
        sel.setAttribute('id', image_grid_group_select_get_html_id(d.group_index));
        sel.setAttribute('onchange', 'image_grid_group_value_onchange(this)');
        var i, value;
        var n = d.values.length;
        var current_value = d.values[d.current_value_index];
        for (i = 0; i < n; ++i) {
            value = d.values[i];
            var o = document.createElement('option');
            o.setAttribute('value', value);
            o.innerHTML = (i + 1) + '/' + n + ': ' + d.name + ' = ' + value;
            if (value === current_value) {
                o.setAttribute('selected', 'selected');
            }

            sel.appendChild(o);
        }
        p.appendChild(sel);

        var next = document.createElement('button');
        next.innerHTML = '>';
        next.setAttribute('value', d.group_index);
        next.setAttribute('onclick', 'image_grid_group_next(this)');
        p.appendChild(next);

        document.getElementById('image_grid_group_panel').appendChild(p);
    }

    function image_grid_group_panel_set_selected_value(group_index) {
        var sel = document.getElementById(image_grid_group_select_get_html_id(group_index));
        sel.selectedIndex = nc_image_grid_group_var[group_index].current_value_index;
    }

    function image_grid_group_panel_set_options(group_index) {
        var sel = document.getElementById(image_grid_group_select_get_html_id(group_index));
        sel.innerHTML = '';

        var i, value;
        var n = nc_image_grid_group_var[group_index].values.length;
        var name = nc_image_grid_group_var[group_index].name;
        var current_value = nc_image_grid_group_var[group_index].values[nc_image_grid_group_var[group_index].current_value_index]
        for (i = 0; i < n; ++i) {
            value = nc_image_grid_group_var[group_index].values[i];
            var o = document.createElement('option');
            o.setAttribute('value', value);
            o.innerHTML = (i + 1) + '/' + n + ': ' + name + ' = ' + value;
            if (value === current_value) {
                o.setAttribute('selected', 'selected');
            }
            sel.appendChild(o);
        }
    }

    function image_grid_group_select_get_html_id(group_index) {
        return 'gi_' + group_index;
    }

    function image_grid_group_select_parse_html_id(id) {
        return parseInt(id.substr(3));
    }

    function image_grid_group_by_select_set_disabled(type, name, is_disabled) {
        var p = document.getElementById('image_grid_toolbar_group_by_select');
        var sel_option_value = image_grid_toolbar_group_by_select_get_html_id(type, name);

        var n = p.options.length;
        var option_value;
        var i;
        for (i = 0; i < n; ++i) {
            if (sel_option_value === p.options[i].value) {
                if (is_disabled) {
                    p.options[i].setAttribute('disabled', 'disabled');
                } else {
                    p.options[i].removeAttribute('disabled');
                }
                break;
            }
        }
    }

    function image_grid_remove_group_by(p) {
        var prefix = 'group_toolbar_';
        var group_index = parseInt(p.parentNode.id.substr(prefix.length));

        if (group_index === 0) {
            image_grid_show_all_images();
        } else {
            // merge all groups that are child of group_index
            image_grid_group_by_merge(nc_image_grid_group, 0, group_index);

            var n = nc_image_grid_group_var.length;
            var p = document.getElementById('image_grid_group_panel');
            var group_panel_id;
            var i;
            for (i = group_index; i < n; ++i) {
                image_grid_remove_html_group_panel(nc_image_grid_group_var[i]);
                image_grid_group_by_select_set_disabled(nc_image_grid_group_var[i].type,
                    nc_image_grid_group_var[i].name,
                    false);
            }
            nc_image_grid_group_var.splice(group_index);

            image_grid_set_content_to_current_group();
        }
    }

    function image_grid_group_by(type, name) {
        if (Object.keys(nc_image_grid_group).length === 0) {
            // first group
            var img_index_array = [];
            var n = nc_img_fn_list_img_index_list.length;
            var i;
            for (i = 0; i < n; ++i) {
                img_index_array.push(nc_img_fn_list_img_index_list[i]);
            }

            nc_image_grid_group = image_grid_split_array_to_group(img_index_array, type, name);
            var new_group_values = Object.keys(nc_image_grid_group);
            nc_image_grid_group_var = [];
            nc_image_grid_group_var.push({ 'type': type, 'name': name, 'current_value_index': 0, 'values': new_group_values, 'group_index': 0 });

            image_grid_add_html_group_panel(nc_image_grid_group_var[0]);
        } else {
            image_grid_group_split_all_arrays(nc_image_grid_group, type, name);

            var i, n, value;
            var current_group_value = nc_image_grid_group;
            n = nc_image_grid_group_var.length;

            for (i = 0; i < n; ++i) {
                value = nc_image_grid_group_var[i].values[nc_image_grid_group_var[i].current_value_index];
                current_group_value = current_group_value[value];
            }
            var new_group_values = Object.keys(current_group_value);
            var group_var_index = nc_image_grid_group_var.length;
            nc_image_grid_group_var.push({ 'type': type, 'name': name, 'current_value_index': 0, 'values': new_group_values, 'group_index': group_var_index });
            image_grid_add_html_group_panel(nc_image_grid_group_var[group_var_index]);
        }

        image_grid_set_content_to_current_group();
    }

    function image_grid_group_by_merge(group, current_level, target_level) {
        var child_value;
        var group_data = [];
        if (current_level === target_level) {
            return image_grid_group_by_collapse(group);
        } else {
            for (child_value in group) {
                group[child_value] = image_grid_group_by_merge(group[child_value], current_level + 1, target_level);
            }
        }
    }

    function image_grid_group_by_collapse(group) {
        var child_value;
        var child_collapsed_value;
        var group_data = [];
        for (child_value in group) {
            if (Array.isArray(group[child_value])) {
                group_data = group_data.concat(group[child_value]);
            } else {
                group_data = group_data.concat(image_grid_group_by_collapse(group[child_value]));
            }
        }
        return group_data;
    }

    // recursively collapse all arrays to list
    function image_grid_group_split_all_arrays(group, type, name) {
        if (Array.isArray(group)) {
            return image_grid_split_array_to_group(group, type, name);
        } else {
            var group_value;
            for (group_value in group) {
                if (Array.isArray(group[group_value])) {
                    group[group_value] = image_grid_split_array_to_group(group[group_value], type, name);
                } else {
                    image_grid_group_split_all_arrays(group[group_value], type, name);
                }
            }
        }
    }

    function image_grid_split_array_to_group(img_index_array, attr_type, attr_name) {
        var grp = {};
        var img_index, img_id, i;
        var n = img_index_array.length;
        var attr_value;

        switch (attr_type) {
            case 'file':
                for (i = 0; i < n; ++i) {
                    img_index = img_index_array[i];
                    img_id = nc_image_id_list[img_index];
                }
                break;
            case 'region':
                var j;
                var region_count;
                for (i = 0; i < n; ++i) {
                    img_index = img_index_array[i];
                    img_id = nc_image_id_list[img_index];
                    region_count = nc_image_metadata[img_id].regions.length;
                }
                break;
        }
        return grp;
    }

    function image_grid_group_next(p) {
        var group_index = parseInt(p.value);
        var group_value_list = nc_image_grid_group_var[group_index].values;
        var n = group_value_list.length;
        var current_index = nc_image_grid_group_var[group_index].current_value_index;
        var next_index = current_index + 1;
        if (next_index >= n) {
            if (group_index === 0) {
                next_index = next_index - n;
                image_grid_jump_to_group(group_index, next_index);
            } else {
                // next of parent group
                var parent_group_index = group_index - 1;
                var parent_current_val_index = nc_image_grid_group_var[parent_group_index].current_value_index;
                var parent_next_val_index = parent_current_val_index + 1;
                while (parent_group_index !== 0) {
                    if (parent_next_val_index >= nc_image_grid_group_var[parent_group_index].values.length) {
                        parent_group_index = group_index - 1;
                        parent_current_val_index = nc_image_grid_group_var[parent_group_index].current_value_index;
                        parent_next_val_index = parent_current_val_index + 1;
                    } else {
                        break;
                    }
                }

                if (parent_next_val_index >= nc_image_grid_group_var[parent_group_index].values.length) {
                    parent_next_val_index = 0;
                }
                image_grid_jump_to_group(parent_group_index, parent_next_val_index);
            }
        } else {
            image_grid_jump_to_group(group_index, next_index);
        }
        image_grid_set_content_to_current_group();
    }

    function image_grid_group_prev(p) {
        var group_index = parseInt(p.value);
        var group_value_list = nc_image_grid_group_var[group_index].values;
        var n = group_value_list.length;
        var current_index = nc_image_grid_group_var[group_index].current_value_index;
        var prev_index = current_index - 1;
        if (prev_index < 0) {
            if (group_index === 0) {
                prev_index = n + prev_index;
                image_grid_jump_to_group(group_index, prev_index);
            } else {
                // prev of parent group
                var parent_group_index = group_index - 1;
                var parent_current_val_index = nc_image_grid_group_var[parent_group_index].current_value_index;
                var parent_prev_val_index = parent_current_val_index - 1;
                while (parent_group_index !== 0) {
                    if (parent_prev_val_index < 0) {
                        parent_group_index = group_index - 1;
                        parent_current_val_index = nc_image_grid_group_var[parent_group_index].current_value_index;
                        parent_prev_val_index = parent_current_val_index - 1;
                    } else {
                        break;
                    }
                }

                if (parent_prev_val_index < 0) {
                    parent_prev_val_index = nc_image_grid_group_var[parent_group_index].values.length - 1;
                }
                image_grid_jump_to_group(parent_group_index, parent_prev_val_index);
            }
        } else {
            image_grid_jump_to_group(group_index, prev_index);
        }
        image_grid_set_content_to_current_group();
    }


    function image_grid_group_value_onchange(p) {
        var group_index = image_grid_group_select_parse_html_id(p.id);
        image_grid_jump_to_group(group_index, p.selectedIndex);
        image_grid_set_content_to_current_group();
    }

    function image_grid_jump_to_group(group_index, value_index) {
        var n = nc_image_grid_group_var[group_index].values.length;
        if (value_index >= n || value_index < 0) {
            return;
        }

        nc_image_grid_group_var[group_index].current_value_index = value_index;
        image_grid_group_panel_set_selected_value(group_index);

        // reset the value of lower groups
        var i, value;
        if (group_index + 1 < nc_image_grid_group_var.length) {
            var e = nc_image_grid_group;
            for (i = 0; i <= group_index; ++i) {
                value = nc_image_grid_group_var[i].values[nc_image_grid_group_var[i].current_value_index];
                e = e[value];
            }

            for (i = group_index + 1; i < nc_image_grid_group_var.length; ++i) {
                nc_image_grid_group_var[i].values = Object.keys(e);
                if (nc_image_grid_group_var[i].values.length === 0) {
                    nc_image_grid_group_var[i].current_value_index = -1;
                    nc_image_grid_group_var.splice(i);
                    image_grid_group_panel_set_options(i);
                    break;
                } else {
                    nc_image_grid_group_var[i].current_value_index = 0;
                    value = nc_image_grid_group_var[i].values[0]
                    e = e[value];
                    image_grid_group_panel_set_options(i);
                }
            }
        }
    }

    function image_grid_set_content_to_current_group() {
        var n = nc_image_grid_group_var.length;

        if (n === 0) {
            image_grid_show_all_images();
        } else {
            var group_img_index_list = [];
            var img_index_list = nc_image_grid_group;
            var i, n, value, current_value_index;
            for (i = 0; i < n; ++i) {
                value = nc_image_grid_group_var[i].values[nc_image_grid_group_var[i].current_value_index];
                img_index_list = img_index_list[value];
            }

            if (Array.isArray(img_index_list)) {
                image_grid_set_content(img_index_list);
            } else {
                console.log('Error: image_grid_set_content_to_current_group(): expected array while got ' + typeof(img_index_list));
            }
        }
    }

    function image_grid_page_next() {
        nc_image_grid_stack_prev_page.push(nc_image_grid_page_first_index);
        nc_image_grid_page_first_index = nc_image_grid_page_last_index;

        image_grid_clear_content();
        nc_image_grid_load_ongoing = true;
        image_grid_page_nav_show_cancel();
        image_grid_content_append_img(nc_image_grid_page_first_index);
    }

    function image_grid_page_prev() {
        nc_image_grid_page_first_index = nc_image_grid_stack_prev_page.pop();
        nc_image_grid_page_last_index = -1;

        image_grid_clear_content();
        nc_image_grid_load_ongoing = true;
        image_grid_page_nav_show_cancel();
        image_grid_content_append_img(nc_image_grid_page_first_index);
    }

    function image_grid_page_nav_show_cancel() {
        var info = document.getElementById('image_grid_nav');
        var html = [];
        html.push('<span>Loading images ... </span>');
        html.push('<span class="text_button" onclick="image_grid_cancel_load_ongoing()">Cancel</span>');
        info.innerHTML = html.join('');
    }

    function image_grid_cancel_load_ongoing() {
        nc_image_grid_load_ongoing = false;
    }


    function nc_region(shape, id, data_img_space, view_scale_factor, view_offset_x, view_offset_y) {
        // Note the following terminology:
        //   view space  :
        //     - corresponds to the x-y plane on which the scaled version of original image is shown to the user
        //     - all the region query operations like is_inside(), is_on_edge(), etc are performed in view space
        //     - all svg draw operations like get_svg() are also in view space
        //
        //   image space :
        //     - corresponds to the x-y plane which corresponds to the spatial space of the original image
        //     - region save, export, git push operations are performed in image space
        //     - to avoid any rounding issues (caused by floating scale factor),
        //        * user drawn regions in view space is first converted to image space
        //        * this region in image space is now used to initialize region in view space
        //
        //   The two spaces are related by nc_model.now.tform.scale which is computed by the method
        //     nc_ctrl.compute_view_panel_to_nowfile_tform()
        //   and applied as follows:
        //     x coordinate in image space = scale_factor * x coordinate in view space
        //
        // shape : {rect, circle, ellipse, line, polyline, polygon, point}
        // id    : unique region-id
        // d[]   : (in view space) data whose meaning depend on shape as follows:
        //        rect     : d[x1,y1,x2,y2] or d[corner1_x, corner1_y, corner2_x, corner2_y]
        //        circle   : d[x1,y1,x2,y2] or d[center_x, center_y, circumference_x, circumference_y]
        //        ellipse  : d[x1,y1,x2,y2,transform]
        //        line     : d[x1,y1,x2,y2]
        //        polyline : d[x1,y1,...,xn,yn]
        //        polygon  : d[x1,y1,...,xn,yn]
        //        point    : d[cx,cy]
        // scale_factor : for conversion from view space to image space
        //
        // Note: no svg data are stored with prefix "_". For example: _scale_factor, _x2
        this.shape = shape;
        this.id = id;
        this.scale_factor = view_scale_factor;
        this.offset_x = view_offset_x;
        this.offset_y = view_offset_y;
        this.recompute_svg = false;
        this.attributes = {};

        var n = data_img_space.length;
        var i;
        this.dview = new Array(n);
        this.dimg = new Array(n);

        if (n !== 0) {
            // IMPORTANT:
            // to avoid any rounding issues (caused by floating scale factor), we stick to
            // the principal that image space coordinates are the ground truth for every region.
            // Hence, we proceed as:
            //   * user drawn regions in view space is first converted to image space
            //   * this region in image space is now used to initialize region in view space
            for (i = 0; i < n; i++) {
                this.dimg[i] = data_img_space[i];

                var offset = this.offset_x;
                if (i % 2 !== 0) {
                    // y coordinate
                    offset = this.offset_y;
                }
                this.dview[i] = Math.round(this.dimg[i] * this.scale_factor) + offset;
            }
        }

        // set svg attributes for each shape
        switch (this.shape) {
            case "rect":
                nc_region_rect.call(this);
                this.svg_attributes = ['x', 'y', 'width', 'height'];
                break;
            case "circle":
                nc_region_circle.call(this);
                this.svg_attributes = ['cx', 'cy', 'r'];
                break;
            case "ellipse":
                nc_region_ellipse.call(this);
                this.svg_attributes = ['cx', 'cy', 'rx', 'ry', 'transform'];
                break;
            case "line":
                nc_region_line.call(this);
                this.svg_attributes = ['x1', 'y1', 'x2', 'y2'];
                break;
            case "polyline":
                nc_region_polyline.call(this);
                this.svg_attributes = ['points'];
                break;
            case "polygon":
                nc_region_polygon.call(this);
                this.svg_attributes = ['points'];
                break;
            case "point":
                nc_region_point.call(this);
                // point is a special circle with minimal radius required for visualization
                this.shape = 'circle';
                this.svg_attributes = ['cx', 'cy', 'r'];
                break;
        }

        this.initialize();
    }

    function nc_region_rect() {
        this.is_inside = nc_region_rect.prototype.is_inside;
        this.is_on_edge = nc_region_rect.prototype.is_on_edge;
        this.move = nc_region_rect.prototype.move;
        this.resize = nc_region_rect.prototype.resize;
        this.initialize = nc_region_rect.prototype.initialize;
        this.dist_to_nearest_edge = nc_region_rect.prototype.dist_to_nearest_edge;
    }

    nc_region_rect.prototype.initialize = function() {
        // ensure that this.(x,y) corresponds to top-left corner of rectangle
        // Note: this.(x2,y2) is defined for convenience in calculations
        if (this.dview[0] < this.dview[2]) {
            this.x = this.dview[0];
            this.x2 = this.dview[2];
        } else {
            this.x = this.dview[2];
            this.x2 = this.dview[0];
        }
        if (this.dview[1] < this.dview[3]) {
            this.y = this.dview[1];
            this.y2 = this.dview[3];
        } else {
            this.y = this.dview[3];
            this.y2 = this.dview[1];
        }
        this.width = this.x2 - this.x;
        this.height = this.y2 - this.y;
        this.recompute_svg = true;
    }

    ///
    /// circle
    ///
    function nc_region_circle() {
        this.is_inside = nc_region_circle.prototype.is_inside;
        this.is_on_edge = nc_region_circle.prototype.is_on_edge;
        this.move = nc_region_circle.prototype.move;
        this.resize = nc_region_circle.prototype.resize;
        this.initialize = nc_region_circle.prototype.initialize;
        this.dist_to_nearest_edge = nc_region_circle.prototype.dist_to_nearest_edge;
    }

    nc_region_circle.prototype.initialize = function() {
        this.cx = this.dview[0];
        this.cy = this.dview[1];
        var dx = this.dview[2] - this.dview[0];
        var dy = this.dview[3] - this.dview[1];
        this.r = Math.round(Math.sqrt(dx * dx + dy * dy));
        this.r2 = this.r * this.r;
        this.recompute_svg = true;
    }


    /// shape : ellipse
    function nc_region_ellipse() {
        this.is_inside = nc_region_ellipse.prototype.is_inside;
        this.is_on_edge = nc_region_ellipse.prototype.is_on_edge;
        this.move = nc_region_ellipse.prototype.move;
        this.resize = nc_region_ellipse.prototype.resize;
        this.initialize = nc_region_ellipse.prototype.initialize;
        this.dist_to_nearest_edge = nc_region_ellipse.prototype.dist_to_nearest_edge;
    }

    nc_region_ellipse.prototype.initialize = function() {
        this.cx = this.dview[0];
        this.cy = this.dview[1];
        this.rx = Math.abs(this.dview[2] - this.dview[0]);
        this.ry = Math.abs(this.dview[3] - this.dview[1]);

        this.inv_rx2 = 1 / (this.rx * this.rx);
        this.inv_ry2 = 1 / (this.ry * this.ry);

        this.recompute_svg = true;
    }

    function nc_region_line() {
        this.is_inside = nc_region_line.prototype.is_inside;
        this.is_on_edge = nc_region_line.prototype.is_on_edge;
        this.move = nc_region_line.prototype.move;
        this.resize = nc_region_line.prototype.resize;
        this.initialize = nc_region_line.prototype.initialize;
        this.dist_to_nearest_edge = nc_region_line.prototype.dist_to_nearest_edge;
    }

    nc_region_line.prototype.initialize = function() {
        this.x1 = this.dview[0];
        this.y1 = this.dview[1];
        this.x2 = this.dview[2];
        this.y2 = this.dview[3];
        this.dx = this.x1 - this.x2;
        this.dy = this.y1 - this.y2;
        this.mconst = (this.x1 * this.y2) - (this.x2 * this.y1);

        this.recompute_svg = true;
    }

    /// shape : polyline
    function nc_region_polyline() {
        this.is_inside = nc_region_polyline.prototype.is_inside;
        this.is_on_edge = nc_region_polyline.prototype.is_on_edge;
        this.move = nc_region_polyline.prototype.move;
        this.resize = nc_region_polyline.prototype.resize;
        this.initialize = nc_region_polyline.prototype.initialize;
        this.dist_to_nearest_edge = nc_region_polyline.prototype.dist_to_nearest_edge;
    }

    nc_region_polyline.prototype.initialize = function() {
        var n = this.dview.length;
        var points = new Array(n / 2);
        var points_index = 0;
        for (var i = 0; i < n; i += 2) {
            points[points_index] = (this.dview[i] + ' ' + this.dview[i + 1]);
            points_index++;
        }
        this.points = points.join(',');
        this.recompute_svg = true;
    }

    function nc_region_polygon() {
        this.is_inside = nc_region_polygon.prototype.is_inside;
        this.is_on_edge = nc_region_polygon.prototype.is_on_edge;
        this.move = nc_region_polygon.prototype.move;
        this.resize = nc_region_polygon.prototype.resize;
        this.initialize = nc_region_polygon.prototype.initialize;
        this.dist_to_nearest_edge = nc_region_polygon.prototype.dist_to_nearest_edge;
    }

    nc_region_polygon.prototype.initialize = function() {
        var n = this.dview.length;
        var points = new Array(n / 2);
        var points_index = 0;
        for (var i = 0; i < n; i += 2) {
            points[points_index] = (this.dview[i] + ' ' + this.dview[i + 1]);
            points_index++;
        }
        this.points = points.join(',');
        this.recompute_svg = true;
    }

    function nc_region_point() {
        this.is_inside = nc_region_point.prototype.is_inside;
        this.is_on_edge = nc_region_point.prototype.is_on_edge;
        this.move = nc_region_point.prototype.move;
        this.resize = nc_region_point.prototype.resize
        this.initialize = nc_region_point.prototype.initialize;
        this.dist_to_nearest_edge = nc_region_point.prototype.dist_to_nearest_edge;
    }

    nc_region_point.prototype.initialize = function() {
        this.cx = this.dview[0];
        this.cy = this.dview[1];
        this.r = 2;
        this.r2 = this.r * this.r;
        this.recompute_svg = true;
    }

    // image buffering
    // xxxx????
    function nc_cancel_current_image_loading() {
        var panel = document.getElementById('project_panel_title');
        panel.innerHTML = 'Project';
        nc_is_loading_current_image = false;
    }

    function nc_show_image(img_index) {
        if (nc_is_loading_current_image) {
            return;
        }

        var img_id = nc_image_id_list[img_index];

        if (!nc_image_metadata.hasOwnProperty(img_id)) {
            console.log('nc_show_image(): [' + img_index + '] ' + img_id + ' does not exist!')
            show_message('The requested image does not exist!')
            return;
        }

        // file_resolve() is not necessary for files selected using browser's file selector
        if (typeof(nc_image_fileref[img_id]) === 'undefined' || !nc_image_fileref[img_id] instanceof File) {
            // try preload from local file or url
            if (typeof(nc_image_src[img_id]) === 'undefined' || nc_image_src[img_id] === '') {
                if (is_url(nc_image_metadata[img_id].filename)) {
                    nc_image_src[img_id] = nc_image_metadata[img_id].filename;
                    nc_show_image(img_index);
                    return;
                }
            }
        }

        if (nc_buffer_img_index_list.includes(img_index)) {
            nc_current_image_loaded = false;
            nc_show_image_from_buffer(img_index).then(function(ok_img_index) {
                // trigger preload of images in buffer corresponding to img_index
                // but, wait until all previous promises get cancelled
                Promise.all(nc_preload_img_promise_list).then(function(values) {
                    nc_preload_img_promise_list = [];
                    var preload_promise = nc_buffer_start_preload(img_index, 0)
                    nc_preload_img_promise_list.push(preload_promise);
                });
            }, function(err_img_index) {
                console.log('nc_show_image_from_buffer() failed for file: ' + nc_image_filename_list[err_img_index]);
                nc_current_image_loaded = false;
            });
        } else {
            // image not in buffer, so first add this image to buffer
            nc_is_loading_current_image = true;
            img_loading_spinbar(img_index, true);
            nc_img_buffer_add_image(img_index).then(function(ok_img_index) {
                nc_is_loading_current_image = false;
                img_loading_spinbar(img_index, false);
                nc_show_image(img_index);
            }, function(err_img_index) {
                nc_is_loading_current_image = false;
                img_loading_spinbar(img_index, false);
                show_page_404(img_index);
                console.log('nc_img_buffer_add_image() failed for file: ' + nc_image_filename_list[err_img_index]);
            });
        }
    }

    function nc_buffer_hide_current_image() {
        file_list_ith_entry_selected(nc_image_index, false);
        nc_clear_reg_canvas(); // clear old shapes
        if (nc_current_image) {
            nc_current_image.classList.remove('visible');
        }
    }

    function nc_show_image_from_buffer(img_index) {
        return new Promise(function(ok_callback, err_callback) {
            nc_buffer_hide_current_image();

            var cimg_html_id = nc_buffer_get_html_id(img_index);

            // nc_current_image was created by nc_img_buffer_add_image()
            nc_current_image = document.getElementById(cimg_html_id);
            if (!nc_current_image) {
                // the said image is not present in buffer, which could be because
                // the image got removed from the buffer
                err_callback(img_index);
                return;
            }
            nc_current_image.classList.add('visible'); // now show the new image

            nc_image_index = img_index; // !!!!
            nc_image_id = nc_image_id_list[nc_image_index];
            nc_current_image_filename = nc_image_metadata[nc_image_id].filename;
            nc_current_image_loaded = true;

            var arr_index = nc_buffer_img_index_list.indexOf(img_index);
            nc_buffer_img_shown_timestamp[arr_index] = Date.now(); // update shown timestamp

            // update the current state of application
            nc_click_x0 = 0;
            nc_click_y0 = 0;
            nc_click_x1 = 0;
            nc_click_y1 = 0;
            nc_is_user_drawing_region = false;
            nc_is_window_resized = false;
            nc_is_user_resizing_region = false;
            nc_is_user_moving_region = false;
            nc_is_user_drawing_polygon = false;
            nc_is_region_selected = false;
            nc_user_sel_region_id = -1;
            nc_current_image_width = nc_current_image.naturalWidth;
            nc_current_image_height = nc_current_image.naturalHeight;

            if (nc_current_image_width === 0 || nc_current_image_height === 0) {
                // for error image icon
                nc_current_image_width = 640;
                nc_current_image_height = 480;
            }

            // set the size of canvas
            // based on the current dimension of browser window
            var de = document.documentElement;
            var image_panel_width = de.clientWidth - leftsidebar.clientWidth - 20;
            if (leftsidebar.style.display === 'none') {
                image_panel_width = de.clientWidth;
            }
            var image_panel_height = de.clientHeight - 2 * ui_top_panel.offsetHeight;

            nc_canvas_width = nc_current_image_width;
            nc_canvas_height = nc_current_image_height;

            if (nc_canvas_width > image_panel_width) {
                // resize image to match the panel width
                var scale_width = image_panel_width / nc_current_image.naturalWidth;
                nc_canvas_width = image_panel_width;
                nc_canvas_height = nc_current_image.naturalHeight * scale_width;
            }
            if (nc_canvas_height > image_panel_height) {
                // resize further image if its height is larger than the image panel
                var scale_height = image_panel_height / nc_canvas_height;
                nc_canvas_height = image_panel_height;
                nc_canvas_width = nc_canvas_width * scale_height;
            }
            nc_canvas_width = Math.round(nc_canvas_width);
            nc_canvas_height = Math.round(nc_canvas_height);
            nc_canvas_scale = nc_current_image.naturalWidth / nc_canvas_width;
            nc_canvas_scale_without_zoom = nc_canvas_scale;
            set_canvas_size(nc_canvas_width, nc_canvas_height);

            // reset all regions to "not selected" state
            toggle_all_regions_selection(false);

            // ensure that all the canvas are visible
            set_display_area_content(NC_DISPLAY_AREA_CONTENT_NAME.IMAGE);

            // update img_fn_list
            file_list_ith_entry_selected(nc_image_index, true);
            file_list_scroll_to_current_file();

            nc_load_canvas_regions(); // image to canvas space transform
            nc_redraw_reg_canvas();
            nc_reg_canvas.focus();

            // Preserve zoom level
            if (nc_is_canvas_zoomed) {
                set_zoom(nc_canvas_zoom_level_index);
            }
            ok_callback(img_index);
        });
    }

    function nc_img_buffer_add_image(img_index) {
        return new Promise(function(ok_callback, err_callback) {
            if (nc_buffer_img_index_list.includes(img_index)) {
                //console.log('nc_img_buffer_add_image(): image ' + img_index + ' already exists in buffer!')
                ok_callback(img_index);
                return;
            }

            var img_id = nc_image_id_list[img_index];
            var img_filename = nc_image_metadata[img_id].filename;
            if (!nc_image_metadata.hasOwnProperty(img_id)) {
                err_callback(img_index);
                return;
            }

            // check if user has given access to local file using
            // browser's file selector
            if (nc_image_fileref[img_id] instanceof File) {
                var tmp_file_object_url = URL.createObjectURL(nc_image_fileref[img_id]);
                var img_id = nc_image_id_list[img_index];
                // Create bim0, bim1, ... 
                var bimg = document.createElement('img');
                bimg.setAttribute('id', nc_buffer_get_html_id(img_index));
                bimg.setAttribute('src', tmp_file_object_url);
                bimg.setAttribute('alt', 'Image loaded from base64 data of a local file selected by user.');
                bimg.addEventListener('error', function() {
                    URL.revokeObjectURL(tmp_file_object_url);
                    project_file_load_on_fail(img_index);
                    err_callback(img_index);
                });
                bimg.addEventListener('load', function() {
                    URL.revokeObjectURL(tmp_file_object_url);
                    nc_img_panel.insertBefore(bimg, nc_reg_canvas);
                    project_file_load_on_success(img_index);
                    file_list_ith_entry_add_css_class(img_index, 'buffered')
                    // add timestamp so that we can apply Least Recently Used (LRU)
                    // scheme to remove elements when buffer is full
                    var arr_index = nc_buffer_img_index_list.length;
                    nc_buffer_img_index_list.push(img_index);
                    nc_buffer_img_shown_timestamp[arr_index] = Date.now(); // though, not seen yet
                    ok_callback(img_index);
                });
                return;
            }

            if (typeof(nc_image_src[img_id]) === 'undefined' || nc_image_src[img_id] === '') {
                err_callback(img_index);
            } else {
                var img_id = nc_image_id_list[img_index];

                var bimg = document.createElement('img');
                bimg.setAttribute('id', nc_buffer_get_html_id(img_index));
                nc_image_src[img_id] = nc_image_src[img_id].replace('#', '%23');
                bimg.setAttribute('src', nc_image_src[img_id]);
                if (nc_image_src[img_id].startsWith('data:image')) {
                    bimg.setAttribute('alt', 'Source: image data in base64 format');
                } else {
                    bimg.setAttribute('alt', 'Source: ' + nc_image_src[img_id]);
                }

                bimg.addEventListener('abort', function() {
                    project_file_load_on_fail(img_index);
                    err_callback(img_index);
                });
                bimg.addEventListener('error', function() {
                    project_file_load_on_fail(img_index);
                    err_callback(img_index);
                });

                // Note: nc_current_image.{naturalWidth,naturalHeight} is only accessible after
                // the "load" event. Therefore, all processing must happen inside this event handler.
                bimg.addEventListener('load', function() {
                    nc_img_panel.insertBefore(bimg, nc_reg_canvas);

                    project_file_load_on_success(img_index);
                    file_list_ith_entry_add_css_class(img_index, 'buffered')
                    // add timestamp so that we can apply Least Recently Used (LRU)
                    // scheme to remove elements when buffer is full
                    var arr_index = nc_buffer_img_index_list.length;
                    nc_buffer_img_index_list.push(img_index);
                    nc_buffer_img_shown_timestamp[arr_index] = Date.now(); // though, not seen yet
                    ok_callback(img_index);
                }, false);
            }
        }, false);
    }

    function nc_buffer_get_html_id(img_index) {
        return 'bim' + img_index;
    }

    function nc_buffer_parse_html_id(html_id) {
        return parseInt(html_id.substr(3));
    }

    function nc_buffer_start_preload(img_index, preload_index) {
        return new Promise(function(ok_callback, err_callback) {
            nc_buffer_preload_img_index = img_index;
            nc_buffer_preload_image(nc_buffer_preload_img_index, 0).then(function(ok_img_index_list) {
                ok_callback(ok_img_index_list);
            });
        });
    }

    function nc_buffer_preload_image(img_index, preload_index) {
        return new Promise(function(ok_callback, err_callback) {
            var preload_img_index = nc_buffer_get_preload_image_index(img_index, preload_index);

            if (nc_buffer_preload_img_index !== nc_image_index) {
                ok_callback([]);
                return;
            }

            // ensure that there is sufficient buffer space left for preloading image
            if (nc_buffer_img_index_list.length > nc_settings.core.buffer_size) {
                while (nc_buffer_img_index_list.length > nc_settings.core.buffer_size) {
                    nc_buffer_remove_least_useful_img();
                    if (nc_image_index !== nc_buffer_preload_img_index) {
                        // current image has changed therefore, we need to cancel this preload operation
                        ok_callback([]);
                        return;
                    }
                }
            }

            nc_img_buffer_add_image(preload_img_index).then(function(ok_img_index) {
                if (nc_image_index !== nc_buffer_preload_img_index) {
                    ok_callback([ok_img_index]);
                    return;
                }

                var next_preload_index = preload_index + 1;
                if (next_preload_index !== NC_IMG_PRELOAD_COUNT) {
                    nc_buffer_preload_image(img_index, next_preload_index).then(function(ok_img_index_list) {
                        ok_img_index_list.push(ok_img_index)
                        ok_callback(ok_img_index_list);
                    });
                } else {
                    ok_callback([ok_img_index]);
                }
            }, function(err_img_index) {
                // continue with preload of other images in sequence
                var next_preload_index = preload_index + 1;
                if (next_preload_index !== NC_IMG_PRELOAD_COUNT) {
                    nc_buffer_preload_image(img_index, next_preload_index).then(function(ok_img_index_list) {
                        ok_callback(ok_img_index_list);
                    });
                } else {
                    ok_callback([]);
                }
            });
        });
    }

    function nc_buffer_get_preload_image_index(img_index, preload_index) {
        var preload_img_index = img_index + NC_IMG_PRELOAD_INDICES[preload_index];
        if ((preload_img_index < 0) || (preload_img_index >= nc_image_count)) {
            if (preload_img_index < 0) {
                preload_img_index = nc_image_count + preload_img_index;
            } else {
                preload_img_index = preload_img_index - nc_image_count;
            }
        }
        return preload_img_index;
    }

    // the least useful image is, one with the following properties:
    // - preload list for current image will always get loaded, so there is no point in removing them from buffer
    // - all the other images in buffer were seen more recently by the image
    // - all the other images are closer (in terms of their image index) to the image currently being shown
    function nc_buffer_remove_least_useful_img() {
        var not_in_preload_list = nc_buffer_img_not_in_preload_list();
        var oldest_buffer_index = nc_buffer_get_oldest_in_list(not_in_preload_list);

        if (nc_buffer_img_index_list[oldest_buffer_index] !== nc_image_index) {
            //console.log('removing oldest_buffer index: ' + oldest_buffer_index);
            nc_buffer_remove(oldest_buffer_index);
        } else {
            var furthest_buffer_index = nc_buffer_get_buffer_furthest_from_current_img();
            nc_buffer_remove(furthest_buffer_index);
        }
    }

    function nc_buffer_remove(buffer_index) {
        var img_index = nc_buffer_img_index_list[buffer_index];
        var bimg_html_id = nc_buffer_get_html_id(img_index);
        var bimg = document.getElementById(bimg_html_id);
        if (bimg) {
            nc_buffer_img_index_list.splice(buffer_index, 1);
            nc_buffer_img_shown_timestamp.splice(buffer_index, 1);
            nc_img_panel.removeChild(bimg);

            file_list_ith_entry_remove_css_class(img_index, 'buffered')
        }
    }

    function nc_buffer_remove_all() {
        var i, n;
        n = nc_buffer_img_index_list.length;
        for (i = 0; i < n; ++i) {
            var img_index = nc_buffer_img_index_list[i];
            var bimg_html_id = nc_buffer_get_html_id(img_index);
            var bimg = document.getElementById(bimg_html_id);
            if (bimg) {
                nc_img_panel.removeChild(bimg);
            }
        }
        nc_buffer_img_index_list = [];
        nc_buffer_img_shown_timestamp = [];
    }

    function nc_buffer_get_oldest_in_list(not_in_preload_list) {
        var i;
        var n = not_in_preload_list.length;
        var oldest_buffer_index = -1;
        var oldest_buffer_timestamp = Date.now();

        for (i = 0; i < n; ++i) {
            var nc_buffer_index = not_in_preload_list[i];
            if (nc_buffer_img_shown_timestamp[nc_buffer_index] < oldest_buffer_timestamp) {
                oldest_buffer_timestamp = nc_buffer_img_shown_timestamp[i];
                oldest_buffer_index = i;
            }
        }
        return oldest_buffer_index;
    }

    function nc_buffer_get_buffer_furthest_from_current_img() {
        var now_img_index = nc_image_index;
        var i, dist1, dist2, dist;
        var n = nc_buffer_img_index_list.length;
        var furthest_buffer_index = 0;
        dist1 = Math.abs(nc_buffer_img_index_list[0] - now_img_index);
        dist2 = nc_image_count - dist1; // assuming the list is circular
        var furthest_buffer_dist = Math.min(dist1, dist2);

        for (i = 1; i < n; ++i) {
            dist1 = Math.abs(nc_buffer_img_index_list[i] - now_img_index);
            dist2 = nc_image_count - dist1; // assuming the list is circular
            dist = Math.min(dist1, dist2);
            // image has been seen by user at least once
            if (dist > furthest_buffer_dist) {
                furthest_buffer_dist = dist;
                furthest_buffer_index = i;
            }
        }
        return furthest_buffer_index;
    }

    function nc_buffer_img_not_in_preload_list() {
        var preload_list = nc_buffer_get_current_preload_list();
        var i;
        var not_in_preload_list = [];
        for (i = 0; i < nc_buffer_img_index_list.length; ++i) {
            if (!preload_list.includes(nc_buffer_img_index_list[i])) {
                not_in_preload_list.push(i);
            }
        }
        return not_in_preload_list;
    }

    function nc_buffer_get_current_preload_list() {
        var i;
        var preload_list = [nc_image_index];
        var img_index = nc_image_index;
        for (i = 0; i < NC_IMG_PRELOAD_COUNT; ++i) {
            var preload_index = img_index + NC_IMG_PRELOAD_INDICES[i];
            if (preload_index < 0) {
                preload_index = nc_image_count + preload_index;
            }
            if (preload_index >= nc_image_count) {
                preload_index = preload_index - nc_image_count;
            }
            preload_list.push(preload_index);
        }
        return preload_list;
    }

    // settings
    function settings_cancel() {
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.SETTINGS) {
            if (nc_display_area_content_name_prev !== '') {
                set_display_area_content(nc_display_area_content_name_prev);
            } else {
                view_single_image();
                nc_redraw_rleg_canvas();
            }
        } else {
            settings_show_current_value();
            set_display_area_content(NC_DISPLAY_AREA_CONTENT_NAME.SETTINGS);
        }
    }

    function settings_save() {
        // check if default path was updated
        var default_path_updated = false;
        if (document.getElementById('nc_settings.core.default_filepath').value !== nc_settings.core.default_filepath) {
            default_path_updated = true;
        }

        var p = document.getElementById('settings_panel');
        var vl = p.getElementsByClassName('value');
        var n = vl.length;
        var i;
        for (i = 0; i < n; ++i) {
            var s = vl[i].childNodes[1];
            var sid_parts = s.id.split('.');
            if (sid_parts[0] === 'nc_settings') {
                var el = nc_settings;
                var found = true;
                var j;
                for (j = 1; j < sid_parts.length - 1; ++j) {
                    if (el.hasOwnProperty(sid_parts[j])) {
                        el = el[sid_parts[j]];
                    } else {
                        // unrecognized setting
                        found = false;
                        break;
                    }
                }
                if (found) {
                    var param = sid_parts[sid_parts.length - 1];
                    if (s.value !== '' || typeof(s.value) !== 'undefined') {
                        el[param] = s.value;
                    }
                }
            }
        }

        p = document.getElementById('project_name');
        if (p.value !== nc_settings.project.name) {
            p.value = nc_settings.project.name;
        }

        if (default_path_updated) {
            nc_file_resolve_all_to_default_filepath();
            nc_show_image(nc_image_index);
        }

        // update color ui ...
        refresh_region_color_picker();

        show_message('Settings saved.');
        settings_cancel();
    }

    function settings_show_current_value() {
        var p = document.getElementById('settings_panel');
        var vl = p.getElementsByClassName('value');
        var n = vl.length;
        for (var i = 0; i < n; ++i) {
            var s = vl[i].childNodes[1];
            var sid_parts = s.id.split('.');
            if (sid_parts[0] === 'nc_settings') {
                var el = nc_settings;
                var found = true;
                for (var j = 1; j < sid_parts.length; ++j) {
                    if (el.hasOwnProperty(sid_parts[j])) {
                        el = el[sid_parts[j]];
                    } else { // unrecognized setting
                        found = false;
                        break;
                    }
                }
                if (found) {
                    s.value = el;
                }
            }
        }
    }

    // find location of file
    function nc_file_resolve_all_to_default_filepath() {
        var img_id;
        for (img_id in nc_image_metadata) {
            if (nc_image_metadata.hasOwnProperty(img_id)) {
                nc_file_resolve_file_to_default_filepath(img_id);
            }
        }
    }

    function nc_file_resolve_file_to_default_filepath(img_id) {
        if (nc_image_metadata.hasOwnProperty(img_id)) {
            if (typeof(nc_image_fileref[img_id]) === 'undefined' || !nc_image_fileref[img_id] instanceof File) {
                if (is_url(nc_image_metadata[img_id].filename)) {
                    nc_image_src[img_id] = nc_image_metadata[img_id].filename;
                } else {
                    nc_image_src[img_id] = nc_settings.core.default_filepath + nc_image_metadata[img_id].filename;
                }
            }
        }
    }

    function nc_file_resolve_all() {
        return new Promise(function(ok_callback, err_callback) {
            var all_promises = [];

            Promise.all(all_promises).then(function(ok_file_index_list) {
                console.log(ok_file_index_list);
                ok_callback();
                //project_file_load_on_success(ok_file_index);
            }, function(err_file_index_list) {
                console.log(err_file_index_list);
                err_callback();
                //project_file_load_on_fail(err_file_index);
            });
        });
    }

    function nc_file_resolve(file_index, search_path_list) {
        return new Promise(function(ok_callback, err_callback) {
            var path_index = 0;
            var p = nc_file_resolve_check_path(file_index, path_index, search_path_list).then(function(ok) {
                ok_callback(ok);
            }, function(err) {
                err_callback(err);
            });
        }, false);
    }

    function nc_file_resolve_check_path(file_index, path_index, search_path_list) {
        return new Promise(function(ok_callback, err_callback) {
            var img_id = nc_image_id_list[file_index];
            var img = new Image(0, 0);

            var img_path = search_path_list[path_index] + nc_image_metadata[img_id].filename;
            if (is_url(nc_image_metadata[img_id].filename)) {
                if (search_path_list[path_index] !== '') {
                    // we search for the the image filename pointed by URL in local search paths
                    img_path = search_path_list[path_index] + get_filename_from_url(nc_image_metadata[img_id].filename);
                }
            }

            img.setAttribute('src', img_path);

            img.addEventListener('load', function() {
                nc_image_src[img_id] = img_path;
                ok_callback(file_index);
            }, false);
            img.addEventListener('abort', function() {
                err_callback(file_index);
            });
            img.addEventListener('error', function() {
                var new_path_index = path_index + 1;
                if (new_path_index < search_path_list.length) {
                    nc_file_resolve_check_path(file_index, new_path_index, search_path_list).then(function(ok) {
                        ok_callback(file_index);
                    }, function(err) {
                        err_callback(file_index);
                    });
                } else {
                    err_callback(file_index);
                }
            }, false);
        }, false);
    }

    // page 404 (file not found)
    function show_page_404(img_index) {
        nc_buffer_hide_current_image();

        set_display_area_content(NC_DISPLAY_AREA_CONTENT_NAME.PAGE_404);

        nc_image_index = img_index; // !!!!
        nc_image_id = nc_image_id_list[nc_image_index];
        nc_current_image_loaded = false;

        file_list_ith_entry_selected(nc_image_index, true);

        document.getElementById('page_404_filename').innerHTML = '[' + (nc_image_index + 1) + ']' + nc_image_metadata[nc_image_id].filename;
    }

    // utils
    function is_url(s) {
        // @todo: ensure that this is sufficient to capture all image url
        if (s.startsWith('http://') || s.startsWith('https://') || s.startsWith('www.')) {
            return true;
        } else {
            return false;
        }
    }

    function get_filename_from_url(url) {
        return url.substring(url.lastIndexOf('/') + 1);
    }

    function fixfloat(x) {
        return parseFloat(x.toFixed(NC_FLOAT_PRECISION));
    }

    function shape_attribute_fixfloat(sa) {
        for (var attr in sa) {
            switch (attr) {
                case 'x':
                case 'y':
                case 'width':
                case 'height':
                case 'r':
                case 'rx':
                case 'ry':
                    sa[attr] = fixfloat(sa[attr]);
                    break;
                case 'all_points_x':
                case 'all_points_y':
                    for (var i in sa[attr]) {
                        sa[attr][i] = fixfloat(sa[attr][i]);
                    }
            }
        }
    }

    // start with the array having smallest number of elements
    // check the remaining arrays if they all contain the elements of this shortest array
    function array_intersect(array_list) {
        if (array_list.length === 0) {
            return [];
        }
        if (array_list.length === 1) {
            return array_list[0];
        }

        var shortest_array = array_list[0];
        var shortest_array_index = 0;
        var i;
        for (i = 1; i < array_list.length; ++i) {
            if (array_list[i].length < shortest_array.length) {
                shortest_array = array_list[i];
                shortest_array_index = i;
            }
        }

        var intersect = [];
        var element_count = {};

        var array_index_i;
        for (i = 0; i < array_list.length; ++i) {
            if (i === 0) {
                // in the first iteration, process the shortest element array
                array_index_i = shortest_array_index;
            } else {
                array_index_i = i;
            }

            var j;
            for (j = 0; j < array_list[array_index_i].length; ++j) {
                if (element_count[array_list[array_index_i][j]] === (i - 1)) {
                    if (i === array_list.length - 1) {
                        intersect.push(array_list[array_index_i][j]);
                        element_count[array_list[array_index_i][j]] = 0;
                    } else {
                        element_count[array_list[array_index_i][j]] = i;
                    }
                } else {
                    element_count[array_list[array_index_i][j]] = 0;
                }
            }
        }
        return intersect;
    }

    function generate_image_index_list(input) {
        var all_img_index_list = [];

        // condition: count format a,b
        var count_format_img_index_list = [];
        if (input.prev_next_count.value !== '') {
            var prev_next_split = input.prev_next_count.value.split(',');
            if (prev_next_split.length === 2) {
                var prev = parseInt(prev_next_split[0]);
                var next = parseInt(prev_next_split[1]);
                var i;
                for (i = (nc_image_index - prev); i <= (nc_image_index + next); i++) {
                    count_format_img_index_list.push(i);
                }
            }
        }
        if (count_format_img_index_list.length !== 0) {
            all_img_index_list.push(count_format_img_index_list);
        }

        //condition: image index list expression
        var expr_img_index_list = [];
        if (input.img_index_list.value !== '') {
            var img_index_expr = input.img_index_list.value.split(',');
            if (img_index_expr.length !== 0) {
                var i;
                for (i = 0; i < img_index_expr.length; ++i) {
                    if (img_index_expr[i].includes('-')) {
                        var ab = img_index_expr[i].split('-');
                        var a = parseInt(ab[0]) - 1; // 0 based indexing
                        var b = parseInt(ab[1]) - 1;
                        var j;
                        for (j = a; j <= b; ++j) {
                            expr_img_index_list.push(j);
                        }
                    } else {
                        expr_img_index_list.push(parseInt(img_index_expr[i]) - 1);
                    }
                }
            }
        }
        if (expr_img_index_list.length !== 0) {
            all_img_index_list.push(expr_img_index_list);
        }

        // condition: regular expression
        var regex_img_index_list = [];
        if (input.regex.value !== '') {
            var regex = input.regex.value;
            for (var i = 0; i < nc_image_filename_list.length; ++i) {
                var filename = nc_image_filename_list[i];
                if (filename.match(regex) !== null) {
                    regex_img_index_list.push(i);
                }
            }
        }
        if (regex_img_index_list.length !== 0) {
            all_img_index_list.push(regex_img_index_list);
        }

        var intersect = array_intersect(all_img_index_list);
        return intersect;
    }

    function annotation_editor_hide() {
        var p = document.getElementById('annotation_editor');
        if (p) {
            p.remove();
        }
    }

    function annotation_editor_show() {
        if (nc_is_region_selected) {
            // remove existing annotation editor (if any)
            annotation_editor_hide();

            // create new container of annotation editor
            var ae = document.createElement('div');
            ae.setAttribute('id', 'annotation_editor');

            ae.classList.add('force_small_font');
            ae.classList.add('display_area_content'); // to enable automatic hiding of this content
            // add annotation editor to image_panel
            var html_position = get_annotation_editor_position(nc_user_sel_region_id);
            ae.style.top = html_position.top;
            ae.style.left = html_position.left;

            nc_display_area.appendChild(ae);
            create_annotation_editor_content();
        }
    }

    function annotation_editor_header_html() {
        // index | Label
        var head = document.createElement('div');
        head.setAttribute('class', 'row');
        head.setAttribute('id', 'annotation_editor_header');

        var id_col = document.createElement('span');
        id_col.setAttribute('class', 'col');
        id_col.innerHTML = 'Index';
        head.appendChild(id_col);

        var label_col = document.createElement('span');
        label_col.setAttribute('class', 'col header');
        label_col.innerHTML = "Label";
        head.appendChild(label_col);

        var ae = document.getElementById('annotation_editor');
        if (ae.childNodes.length === 0) {
            ae.appendChild(head);
        } else {
            if (ae.firstChild.id === 'annotation_editor_header') {
                ae.replaceChild(head, ae.firstChild);
            } else { // header node is absent
                ae.insertBefore(head, ae.firstChild);
            }
        }
    }

    function create_annotation_editor_content() {
        return new Promise(function(ok_callback, err_callback) {
            var ae = document.getElementById('annotation_editor');
            if (ae) {
                ae.innerHTML = '';
                annotation_editor_header_html();
                annotation_editor_metadata_html();
            }
            ok_callback();
        });
    }

    function annotation_editor_metadata_html() {
        var ae = document.getElementById('annotation_editor');
        if (nc_display_area_content_name === NC_DISPLAY_AREA_CONTENT_NAME.IMAGE) {
            ae.appendChild(annotation_editor_metadata_row_html(nc_user_sel_region_id));
        }
    }

    function annotation_editor_metadata_row_html(row_id) {
        // Index == row_id + 1, Selector is created by project settings label list !
        var row = document.createElement('div');
        row.setAttribute('class', 'row');
        row.setAttribute('id', 'ae_region_' + row_id);

        var id_col = document.createElement('span');
        id_col.setAttribute('class', 'col id');
        id_col.innerHTML = (row_id + 1);
        row.appendChild(id_col);

        var label_col = document.createElement('span');
        label_col.setAttribute('class', 'col');

        // Create select ...  
        var attr_html_id = 'region__' + row_id;
        var sel = document.createElement('select');
        sel.setAttribute('id', attr_html_id);
        sel.setAttribute('onchange', 'annotation_editor_on_metadata_close(this)');

        var option_id;
        var option_selected = false;
        var option_set = nc_settings.core.default_labels.split(",");

        // Search selected option
        var attr_value = 0;
        if (row_id >= 0 && row_id < nc_canvas_regions.length) {
            for (var i in option_set) {
                if (option_set[i] == nc_canvas_regions[row_id].attributes['label']) {
                    attr_value = i;
                    break;
                }
            }
        }

        for (option_id in option_set) {
            var option_html_id = attr_html_id + '__' + option_id;
            var option = document.createElement('option');
            option.setAttribute('value', option_html_id);

            if (option_id === attr_value) {
                option.setAttribute('selected', 'selected');
                option_selected = true;
            }
            option.innerHTML = option_set[option_id];
            sel.appendChild(option);
        }
        if (!option_selected) {
            sel.selectedIndex = '-1';
        }
        label_col.appendChild(sel);

        row.appendChild(label_col);
        return row;
    }

    function get_annotation_editor_position(region_id) {
        var html_position = {};
        var r = nc_canvas_regions[region_id]['attributes'];
        var shape = r['name'];
        switch (shape) {
            case 'rect':
                html_position.top = r['y'] + parseInt(r['height'] / 2);
                html_position.left = r['x'] + parseInt(r['width'] / 2);
                break;
            case 'circle':
                html_position.top = r['cy']; //  + r['r'];
                html_position.left = r['cx'];
                break;
            case 'ellipse':
                html_position.top = r['cy']; // + r['ry'] * Math.cos(r['theta']);
                html_position.left = r['cx']; // - r['ry'] * Math.sin(r['theta']);
                break;
            case 'polygon':
            case 'polyline':
                var most_left =
                    Object.keys(r['all_points_x']).reduce(function(a, b) {
                        return r['all_points_x'][a] > r['all_points_x'][b] ? a : b
                    });
                html_position.top = Math.max(r['all_points_y'][most_left]);
                html_position.left = Math.max(r['all_points_x'][most_left]);
                break;
            case 'point':
                html_position.top = r['cy'];
                html_position.left = r['cx'];
                break;
        }
        html_position.top = html_position.top + nc_img_panel.offsetTop + NC_REGION_EDGE_TOL + 'px';
        html_position.left = html_position.left + nc_img_panel.offsetLeft + NC_REGION_EDGE_TOL + 'px';
        return html_position;
    }

    // invoked when user end annotations
    function annotation_editor_on_metadata_close(p) {
        var pid = annotation_editor_extract_html_id(p.value);
        // row_id = 4 -- attr = region -- option_id = 2
        var labels = nc_settings.core.default_labels.split(",");

        // Save result
        var label = labels[pid.option_id];
        nc_canvas_regions[pid.row_id].attributes['label'] = label;
        nc_image_metadata[nc_image_id].regions[pid.row_id].attributes['label'] = label;

        annotation_editor_hide();
        nc_redraw_reg_canvas();
    }

    function annotation_editor_extract_html_id(html_id) {
        var parts = html_id.split('__');
        var parsed_id = {};
        switch (parts.length) {
            case 3:
                // html_id : attribute-id__row-id__option_id
                parsed_id.attr_id = parts[0];
                parsed_id.row_id = parts[1];
                parsed_id.option_id = parts[2];
                break;
            case 2:
                // html_id : attribute-id__row-id
                parsed_id.attr_id = parts[0];
                parsed_id.row_id = parts[1];
                break;
            default:
        }
        return parsed_id;
    }

    // pts = [x0,y0,x1,y1,....]
    function polygon_to_bbox(pts) {
        var xmin = +Infinity;
        var xmax = -Infinity;
        var ymin = +Infinity;
        var ymax = -Infinity;
        for (var i = 0; i < pts.length; i = i + 2) {
            if (pts[i] > xmax) {
                xmax = pts[i];
            }
            if (pts[i] < xmin) {
                xmin = pts[i];
            }
            if (pts[i + 1] > ymax) {
                ymax = pts[i + 1];
            }
            if (pts[i + 1] < ymin) {
                ymin = pts[i + 1];
            }
        }
        return [xmin, ymin, xmax - xmin, ymax - ymin];
    }
    </script>
    <!-- END: Contents of js-->
</body>

</html>